<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- saved from url=(0123)file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#dashboard -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">











  
  
  
  
  
  
  
  
  
  
  











  
  
  
  
  
  
  
  
  
  
  <meta http-equiv="Content-Style-Type" content="text/css">











  
  
  
  
  
  
  
  
  
  
  <link rel="STYLESHEET" type="text/css" href="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/minimal.css">











  
  
  
  
  
  
  
  
  
  
  <script src="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/common.js" type="text/javascript"></script>
  
  
  
  
  
  
  
  
  
  
  <title>LabVIEW Robotics Programming Guide for FIRST Robotics Competition</title>
</head>


<body style="background-color: rgb(255, 255, 255);">











<noscript>
&lt;p class="Body"&gt;JavaScript is disabled. &lt;a
href="lvhelp.chm::/JavaScript_Disabled.html"&gt;Details&lt;/a&gt;&lt;/p&gt;
&lt;hr width="100%" noshade&gt;
</noscript>











<a name="TOC"></a>
<h1>LabVIEW Robotics Programming
Guide for <em>FIRST</em>
Robotics
Competition</h1>











<p class="Body">©
January 2012</p>











<p class="Body">Use the
following tutorials to set up hardware and
software for <em>FIRST</em>
Robotics Competition (FRC) and to develop
LabVIEW programs that control the robot.</p>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#whatsnew">What's
New</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#vocab">FRC
Terminology</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#overview">System
Setup</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#configcRIO">Tutorial
1—Setting up the roboRIO</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#confignetwork">Tutorial
2—Setting up the Robot Radio</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#configcamera">Tutorial
3—Setting up the Axis Camera</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#devrobproj">Tutorial
4—Developing a Robot Project</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#editrobproj">Tutorial
5—Editing Team Code VIs</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#dashboard">Tutorial
6—Creating a Custom Dashboard</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#exampleprog">Tutorial
7—Integrating Examples into Robot
Code</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#intvision">Tutorial
8—Integrating Vision into Robot Code</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#CanGettingStarted">Tutorial
9—Getting Started with CAN</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#simulation">Tutorial
10—Robot Simulation</a><br>









<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#command">Tutorial
11—Command and Control Project</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#troubleshoot">Troubleshooting
the Robot</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#onlinetutorials">Online
Forums and Tutorials</a><br>











<br>











<hr>
<h2><a name="whatsnew">What's New</a></h2>











<p class="Body">The
following list describes new and changed features
in LabVIEW for FRC 2017:</p>











<ul>











  <li><strong>LabVIEW
for FRC software—</strong>runs
on LabVIEW
2016.</li>











  <li><strong>Robot
Simulation—</strong>allows
you to program and
run robot code without a roboRIO FRC device. When you run in
simulated mode, the FRC Simulation Viewer opens. &nbsp;The viewer
is a
simulated environment where you can test drive your simulated robot.
&nbsp;The code from a simulated robot can be built for your real
robot.
&nbsp;For more information see&nbsp;<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#simulation">Tutorial
10—Robot Simulation</a></li>











  <li><strong></strong>
    
    
    
    
    
    
    
    
    
    
    <ul>











    
    
    
    
    
    
    
    
    
    
    </ul>











    <strong>Updated Driver Station</strong>
    
    
    <br>







    
    
    
    
    
    
    
    <ul>











      



      <li><strong>Test
Mode—</strong>allows you
to run custom
test code, as well as commands when using the command and control architecture.</li>











      <li><strong>Driver
Station Log Viewer—</strong>improved
to
log more data and can be launched from the Driver Station.</li>











      <li><strong>View Console—</strong>lets you
view a larger message console window.</li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li><strong>Updated
Dashboard</strong>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><span style="font-weight: bold;">Camera tab</span><strong>—</strong>makes it easier to use multiple cameras.<strong></strong></li>




      <li><strong>Two projects—</strong>when creating your own dashboard, there are now two projects to choose from. &nbsp;<span style="font-weight: bold;">Dashboard</span> is the&nbsp;project used to create the prebuilt dashboard. &nbsp;<span style="font-weight: bold;">Dashboard Simple</span> is a new project with less features.</li>











      



    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li><strong>WPI
Robotics Library VIs</strong>
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><span style="font-weight: bold;">Third Party CAN Motor Control</span>
- to allow for multiple third party vendors, there is now a Third Party <span style="font-weight: bold;">CanMotor</span>
subpalette within the MotorControl palette. &nbsp;This new CanMotor
subpalette gets populated when you install third party CAN software.
&nbsp;For example if you want to control a Talon SRX motor controller
using CAN, you will need to install the CAN software from Cross the
Road Electronics.&nbsp; <span style="font-weight: bold;"></span></li>











      <li><span style="font-weight: bold;">Third Party Sensors</span>
- for sensors that are not directly supported in WPILib, there is now a <span style="font-weight: bold;">Third Party Sensors</span>
subpalette within the Sensors palette where vendors can choose to
include their own palettes of VIs for specific sensors they manufacture.</li>











      <li><span style="font-weight: bold;">Third Party Actuators</span>
-&nbsp;for actuators that are not directly supported in WPILib, there is now a <span style="font-weight: bold;">Third Party Actuators</span>
subpalette within the Actuators palette where vendors can choose to
include their own palettes of VIs for specific actuators they
manufacture.</li>











      
    
    
    
    
    </ul>











  </li>











  <li><strong>New
Tutorials</strong> <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#command">Tutorial
11—Command and Control Project</a></li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li><strong>New
Examples—</strong>include
a 2017 specific vision example. Access FRC examples from
the Support page of the Getting Started Window or by selecting <strong>Help»Find
Examples</strong>.</li>







  <li><span style="font-weight: bold;">Control
System Devices</span>
- While not new this year, there are&nbsp;devices&nbsp;manufactured by vendors other
than
National Instruments that can be configured using the National
Instruments web interface. &nbsp;For example you can update the
firmware of the PCM, PDP, and Talon motor controllers.
&nbsp;Complete
the following steps to update the firmware on these devices. </li>











  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>Connect to the roboRIO over USB</li>











    <li>Type 172.22.11.2 into your web browser.</li>











    <li>Click on Login. User name = Admin and password should be
left
empty (unless you have changed this)</li>











    <li>Select the device and press the <span style="font-weight: bold;">Update Firmware</span>
button.</li>











    <li>Navigate to and choose the firmware file. &nbsp;They
are
typically located in: Users\Public\Public Documents\FRC</li>











    <li>Press <span style="font-weight: bold;">Begin
Update</span> -
you
should&nbsp;see a&nbsp;message that the firmware is updating
and a
message letting you know when it is complete.</li>











  
  
  
  
  
  
  
  
  
  
  </ul>











</ul>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="vocab">FRC Terminology</a></h2>











<p class="Body">The
following terms are useful to know as you build and
program a robot with LabVIEW for FRC and as you read this guide.</p>











<h4>roboRIO</h4>











<p class="Body">The
roboRIO&nbsp;is a
small, rugged controller consisting of an embedded real-time processor,
an FPGA (field-programmable gate array), and integrated (on board)
I/O. The roboRIO also has an MXP port for additional I/O. The on-board
I/O includes digital input/output, analog input, PWM output, relay
output, I2C bus, SPI bus, CAN bus, and a UART RS-232 port. It also has
one USB Device port and two USB Host ports. The MXP connector includes
digital input/output, analog input, analog output, PWM output, I2C bus,
SPI bus, and a UART TTL port. &nbsp;The MXP digital lines are
shared
with the other I/O - meaning they can be individually configured as
digital or one of the other designated I/O types.</p>











The
roboRIO&nbsp;serves as the "brain" of each
robot and runs the program you develop and deploy from LabVIEW. The
roboRIO also receives data from the driver station and the
various sensors that you connect to it. Furthermore, the
roboRIO hosts a system watchdog. The system watchdog shuts
down all motors if the communication network fails.
<h4>FRC Driver Station</h4>











<p class="Body">The driver
station is a program that passes data
between the host computer; input devices, such as joysticks and game
controllers; and the robot. &nbsp;The driver station receives data
from
the input devices and sends the data to the roboRIO&nbsp;on the
robot. &nbsp;The FRC Driver Station must be running and in Teleop
Enabled
mode before you can drive a robot. &nbsp;&nbsp;The FRC Driver Station can
be
launched from the Start menu or from the Desktop shortcut.</p>











<p class="Body">During
development you can connect the driver station
PC directly to the roboRIO device using a USB cable.
Or, the driver station can communicate with the roboRIO
through a wireless access point on the robot. During competition you
must connect the driver station PC&nbsp;directly to the Field
Management
System (FMS) using an Ethernet cable.
</p>











<h4>Autonomous and Teleop Modes</h4>











<p class="Body">FRC robots
can run in two modes: Autonomous mode and
Teleop mode.</p>











<p class="Body">In
Autonomous mode, the robot moves without receiving
commands from input devices, such as joysticks and game controllers.
You develop a program in LabVIEW and deploy that program to the
roboRIO&nbsp;on the robot. When you run the program, the robot
moves and behaves according to instructions in the program.</p>











<p class="Body">In Teleop
mode, the robot moves in response to commands
it receives from input devices. As in Autonomous mode, you develop a
program in LabVIEW and deploy that program to the roboRIO on
the robot. The program must contain instructions that allow the robot
to receive data from the input devices and respond accordingly. When
you run the program, you then can use the input devices to manipulate
the behavior of the robot. If you want the robot to respond to commands
it receives from input devices, connect the input devices to the driver
station PC using a USB connection. You can use any joystick, game
controller, or other HID that you choose.</p>











<p class="Body">Most FRC
programs include code for both Autonomous and
Teleop modes, and then you can decide which code to run depending on
information from the FMS.
The FRC roboRIO Robot Project wizard creates template code that
includes
both
Autonomous and Teleop code.</p>











<h4>Enabled and Disabled Status</h4>











<p class="Body">The FRC
software allows you to enable and disable the
program running on the roboRIO. For example, you might want
the program to continue running, but you do not want any part of the
robot to move for safety reasons. Setting the Disabled status kills the
system watchdog, which disables the PWM, relay, and solenoid outputs of
the robot.</p>











<p class="Body">When the
robot is in the Disabled status, you still can
use input devices, such as joysticks and game controllers, to send
information to the robot. You also still can read information from
sensors and perform image processing on the roboRIO.
Therefore, you can develop your robotics program to handle the Disabled
status such that the program handles initialization and processing
tasks, rather than motion tasks, when the robot is disabled. When you
set the status of the robot to Enabled status, the system watchdog
re-enables the PWM, relay, and solenoid outputs. Therefore, you can
develop your robotics program to move motors and drive the robot when
the robot is enabled.</p>











<p class="Body">Ensure the
program you run on the roboRIO
handles the Disabled and Enabled statuses appropriately. Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#devrobproj">Tutorial 4—Developing a
Robot Project</a> for
more information about the robot projects.</p>











<h4>Init, Execute, and Stop Call
Contexts</h4>











<p class="Body">The robot
can be in one of the following states:</p>











<ul>











  <li>Autonomous Disabled</li>











  <li>Autonomous Enabled</li>











  <li>Teleop Disabled</li>











  <li>Teleop Enabled</li>











</ul>











<p class="Body">For each of
these states, the robot can also be in one
of three call contexts: Init, Execute, or Stop. Use the Init call
context to tell the robot to perform any initialization tasks, such as
opening sensor or I/O references. Use the Execute call context to tell
the robot to move, read and write data, or perform some other behavior.
Use the Stop call context to tell the robot to perform tasks such as
stopping motors and closing references.</p>











<h4>Estop State</h4>











<p class="Body">The
emergency stop, or Estop, state is an emergency
state that shuts down the robot immediately. If the robot reaches the
Estop state, you must reboot the roboRIO to restart execution.</p>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="overview">System Setup</a></h2>











<p class="Body">A robot
controller system might consist of the
following subsystems:</p>











<ol class="List-abc">











  <li><strong>Driver
Console</strong>—Establishes
communication
between the roboRIO on the robot and the host computer. This
subsystem includes a computer that runs the driver station program; one
or more input devices, such as joysticks and game controllers; and a
host computer.
    
    
    
    
    
    
    
    
    
    
    <table class="Borderless">











      <tbody>











        <tr>











          <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











          <td><strong>Note</strong>&nbsp;&nbsp;The
host computer can be
the same computer that runs the driver station program.</td>











        </tr>











      
      
      
      
      
      
      
      
      
      
      </tbody>
    
    
    
    
    
    
    
    
    
    
    </table>











  </li>











  <li><strong>Wireless
Communication</strong>—Establishes
wireless communication between the driver station and the robot. This
subsystem includes wireless access points for the driver station and
the roboRIO.</li>











  <li><strong>Robot</strong>—Consists
of all parts that make up
the moving robot. This subsystem includes the roboRIO with
optional MXP board or connections,
and an optional USB or Axis camera.</li>











</ol>











<h2>Robot Subsystem</h2>











<p class="Body">This
section describes the roboRIO and Axis camera
components of the robot subsystem and then how you can use LabVIEW to
interface with this subsystem.</p>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#criodescrip">roboRIO</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#cameradescrip">Axis
Camera</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#LVsoftwaredescrip">LabVIEW
for FRC</a><br>











<h3><a name="criodescrip">roboRIO</a></h3>











<p class="Body">The roboRIO
consists of the following
components:</p>











<h4>Real-Time Operating System</h4>











<p class="Body">Most
LabVIEW applications run on a general-purpose
operating system (OS) like Windows, Mac OS, or Linux. Some applications
require real-time performance that general-purpose operating systems
cannot guarantee.</p>











<p class="Body">Real-time
systems are deterministic. Determinism is the
characteristic of a system that describes how consistently the system
responds to external events or performs operations within a given time
limit. Jitter is a measure of the extent to which execution timing
fails to meet deterministic expectations. Most real-time applications
require timing behavior to consistently execute within a small window
of acceptable jitter.</p>











<p class="Body">You can run
real-time programs on a real-time target
such as a roboRIO. The roboRIO runs the NI Linux Real-Time Operating
System. In LabVIEW, you deploy
an application to run on the roboRIO from the&nbsp;<strong>Target</strong>
directory
of the <strong>Project Explorer</strong>
window. Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#devrobproj">Tutorial
4—Developing a
Robot Project</a> for more
information about deploying an application
to the roboRIO.</p>











<h4>FPGA</h4>











<p class="Body">The roboRIO
includes a built-in,
high-performance FPGA. An FPGA is an embedded chip that can be
reconfigured for different applications. However, the FPGA in the FRC
roboRIO is already configured for FRC applications, and you
cannot change the configuration. The&nbsp;I/O&nbsp;on the
roboRIO
interfaces directly with the FPGA.</p>











<h4><a name="iomodules">I/O</a></h4>











<p class="Body">The roboRIO
contains the following on-board connections:</p>











<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">











  <tbody>











    <tr>











      <td><span style="font-weight: bold;">Connection</span></td>











      <td><span style="font-weight: bold;">Typical
Uses</span><br>











      </td>











    </tr>











    <tr>











      <td>10 Digital I/O Channels</td>











      <td>TTL signals, reading
limit switches, counting switches, sonar
devices, encoders, relays,&nbsp;counters</td>











    </tr>











    <tr>











      <td>4 Analog Input Channels</td>











      <td>reading 0-5 VDC,
accelerometers, sonar,&nbsp;gyros</td>











    </tr>











    <tr>











      <td>10 PWM Channels</td>











      <td>motors, servos</td>











    </tr>











    <tr>











      <td>4 Relay Channels</td>











      <td>forward/reverse relays</td>











    </tr>











    <tr>











      <td>CAN Bus</td>











      <td>motors,
pneumatics,&nbsp;reading various currents, voltages,
and faults</td>











    </tr>











    <tr>











      <td>I2C Bus</td>











      <td>accelerometers, sonar</td>











    </tr>











    <tr>











      <td>SPI Bus</td>











      <td>accelerometers, gyro</td>











    </tr>











    <tr>











      <td>Serial</td>











      <td>UART RS-232</td>











    </tr>











    <tr>











      <td>RSL</td>











      <td>Robot Signal Light</td>











    </tr>











    <tr>











      <td>1 USB Device Port</td>











      <td>imaging the roboRIO,
downloading VIs or built applications</td>











    </tr>











    <tr>











      <td>2 USB Host Ports</td>











      <td>camera, radio (these do not support joysticks)</td>











    </tr>











    <tr>











      <td>Ethernet</td>











      <td>camera, radio</td>











    </tr>











    <tr>











      <td>Input Power</td>











      <td>12 VDC in to power the
roboRIO</td>











    </tr>











    <tr>











      <td>MXP port</td>











      <td>see table below</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body"></p>











<p class="Body">The MXP (<span style="font-weight: bold;">M</span>yRIO
e<span style="font-weight: bold;">X</span>pansion
<span style="font-weight: bold;">P</span>ort)
connector contains the
following connections:</p>











<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">











  <tbody>











    <tr>











      <td>4 Analog Input Channels</td>











      <td>reading 0-5 VDC,
accelerometers, sonar,&nbsp;gyros</td>











    </tr>











    <tr>











      <td>2 Analog Output Channels</td>











      <td>writing 0-5 VDC</td>











    </tr>











    <tr>











      <td>16 Digital I/O Channels
(shared)</td>











      <td>TTL signals, reading
limit switches, counting switches, sonar
devices, encoders, relays,&nbsp;counters</td>











    </tr>











    <tr>











      <td>10 PWM Channels (shared
with DIO)</td>











      <td>motors, servos</td>











    </tr>











    <tr>











      <td>SPI Bus (shared with DIO)</td>











      <td>accelerometers, gyro</td>











    </tr>











    <tr>











      <td>I2C Bus (shared with DIO)</td>











      <td>accelerometers, sonar</td>











    </tr>











    <tr>











      <td>Serial</td>











      <td>UART&nbsp;TTL</td>











    </tr>











    <tr>











      <td>GND, +5 VDC, +3.3 VDC</td>











      <td>power for sensors etc.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body">Additionally
the roboRIO has an internal 3-axis
accelerometer. &nbsp;Click the <strong>Find
FRC
Examples</strong> link on the <strong>Getting
Started</strong> window
to find example programs that use the I/O listed in the tables above.</p>











<p class="Body"></p>











<p class="Body">The roboRIO
has the following built-in LEDs:</p>











<table style="text-align: left; width: 100%;" border="1" cellpadding="2" cellspacing="2">











  <tbody>











    <tr>











      <td>POWER</td>











      <td>Green =&nbsp;power
is valid</td>











    </tr>











    <tr>











      <td>STATUS</td>











      <td>Yellow Solid - booting,
Yellow Blinking - safe mode or boot
failure</td>











    </tr>











    <tr>











      <td>RADIO</td>











      <td></td>











    </tr>











    <tr>











      <td>COMM</td>











      <td></td>











    </tr>











    <tr>











      <td>MODE</td>











      <td></td>











    </tr>











    <tr>











      <td>RSL</td>











      <td>Robot Signal Light</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body"></p>











<p class="Body"></p>











<a name="cameradescrip">Axis
Camera</a>
<p class="Body">Your robot
subsystem may include an Axis camera that you
can use to perform image acquisition. You can acquire images and
process them directly on the roboRIO.</p>











<p class="Body">Use the
Camera VIs to specify settings for the Axis
camera and to acquire images with the camera. Use the FIRST Vision VIs
to process the images you acquire.</p>











<p class="Body">Click the <strong>Find
FRC Examples</strong> link on
the <strong>Getting Started</strong>
window to find example programs.
You also can access this information in the <em>LabVIEW
Help</em>,
available by selecting <strong>Help»LabVIEW
Help</strong>.</p>











<p class="Body">The roboRIO
is headless, so you cannot view
the images being acquired. However, by default the image is sent over
Ethernet directly to the Dashboard where it is displayed. You can also
do image processing in the Dashboard code, and pass control information
back to the robot.</p>











You also can use live front panel debugging to view the
images on the host computer. Click the <strong>Run</strong>
button of
the VI you want to deploy to the roboRIO to perform live
front panel debugging.
<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;You&nbsp;perform
live front panel debugging only during
development.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body">Before you
can use the Axis camera, you must configure
it for FRC. Use the Setup Axis Camera Tool, available by
selecting <strong>Tools»Setup
Axis Camera</strong>, to configure
the Axis camera. You can also launch this tool from the Utilities tab
of the Getting Started Window.</p>











<h3><a name="LVsoftwaredescrip">LabVIEW for FRC</a></h3>











<p class="Body">LabVIEW for
FRC includes LabVIEW 2016, the LabVIEW
Real-Time Module, the NI Vision Development Module, the NI-IMAQdx
driver, the NI-RIO driver,
and FRC–specific VIs. Use this software to interface directly
with the various roboRIO I/O and manipulate
the behavior of the robot you build. You can use LabVIEW to develop
a program that runs on the host computer or that you can deploy and run
on the roboRIO.</p>











<ul>











  <li><strong>FRC
roboRIO VIs</strong>—The
FRC roboRIO VIs
are divided into two palettes, FIRST Vision and WPI Robotics Library.
Use the FIRST Vision VIs to process images you acquire with the Axis
camera. Use the WPI Robotics Library VIs to interface with the roboRIO
and perform tasks such as sending and receiving data
from sensors and for driving motors. The WPI Robotics Library VIs are
analogous to the WPI Robotics Library, a library of&nbsp;C++
functions
developed by Worcester Polytechnic Institute (WPI) for robotics
applications. <br>











    <br>











Click the <strong>Find FRC
Examples</strong> link on the <span style="font-weight: bold;">Support</span>
tab of the <strong>Getting
Started</strong> window to find
example programs. You also can access
this information in the <em>LabVIEW
Help</em>, available by selecting <strong>Help»LabVIEW
Help</strong>.<br>











    <br>











  </li>











  <li><strong>Setup
Axis Camera Tool</strong>—Use
the Setup Axis
Camera Tool, available by selecting <strong>Tools»Setup
Axis
Camera</strong>, to setup the Axis
camera for use with the Robot
Radio. <br>











    <br>











Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#configcamera">Tutorial
3—Setting up the Axis
Camera</a> for more information
about configuring the Axis camera.<br>











    <br>











  </li>











  <li><strong>roboRIO
Imaging Tool</strong>—Use
the roboRIO
Imaging Tool, available by selecting <strong>Tools»roboRIO
Imaging Tool</strong> in LabVIEW, to
configure the roboRIO
with a start-up image. You also can restore an image on the roboRIO or
update the roboRIO with a new Team Number. <br>











    <br>











Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#configcRIO">Tutorial
1—Setting up the roboRIO</a>
for more information
about configuring the roboRIO.</li>











</ul>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="configcRIO">Tutorial
1—Setting up the
roboRIO</a></h2>











<p class="Body">You must
configure the roboRIO and the Axis
camera before you can run a robotics program on the robot.</p>











<p class="Body">To
configure the roboRIO, you must A)&nbsp;connect the computer to the
roboRIO, and then B) run the roboRIO Imaging Tool.</p>











<h4>A)&nbsp;Connecting the
Computer to
the roboRIO</h4>











<p class="Body">Use a USB
cable to connect the computer (USB A-Type) to
the USB Device Port (USB B-Type) of the roboRIO (the single USB port
next to the
INPUT power). Then configure the roboRIO with the roboRIO Imaging Tool.</p>











<h4>B) Running the roboRIO
Imaging Tool</h4>











<h4>Considerations Before Running
the roboRIO Imaging Tool</h4>











<ul>











  <li>Do not use the roboRIO
Imaging Tool on the roboRIO
over a wireless connection. If the connection is lost, the data that
the roboRIO Imaging Tool writes to the roboRIO is
corrupted.</li>











  <li>Do not use the roboRIO
Imaging Tool on the roboRIO over Ethernet. &nbsp;While this should
work, it is not as reliable as USB.</li>











  <li>Do not use Measurement
&amp; Automation Explorer (MAX) to install
additional software on the roboRIO. MAX overwrites the FRC
VIs on the roboRIO. If you use MAX to install additional
software on the roboRIO, you must use the roboRIO Imaging
Tool to restore the device to a usable state.</li>











</ul>











<h4>Running the roboRIO Imaging
Tool</h4>











<p class="Body">Complete
the following steps to configure the roboRIO with the roboRIO Imaging
Tool.</p>











<ol>











  <li>Select&nbsp;<strong>roboRIO Imaging Tool 2017</strong>&nbsp;from the <span style="font-weight: bold;">Utilities</span> tab of the
LabVIEW Getting Started Window, or by selecting <strong>Tools»roboRIO
Imaging Tool</strong> from within
LabVIEW.</li>











  <li>Select the roboRIO
you want to configure from the&nbsp;<span style="font-weight: bold;">roboRIO Targets</span> table. This
table
lists all roboRIOs
connected to the host computer.</li>











  <li>Place a checkmark in the <strong>Format
Target</strong>
checkbox.</li>











  <li>From the <strong>Select
Image</strong> list, select the most
recent <span class="Monospace">.zip</span>
file to download the most
recent image to the roboRIO. If you do not see a <span class="Monospace">.zip</span>
file, you must install the FRC LabVIEW
Update Suite.</li>











  <li>Enter your team number in
the <strong>Team Number</strong>
text box.</li>











  <li>Click the&nbsp;<strong>Reformat</strong>
button to apply the changes you
made and download the image to the roboRIO. Do not turn off
power to the roboRIO or interfere with the USB connection
while the roboRIO Imaging Tool downloads the image to the roboRIO.</li>











</ol>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>
&nbsp;&nbsp;If
the roboRIO Imaging Tool
fails to update the roboRIO, turn off Windows
Firewall in the Control Panel of Windows.
      
      
      
      
      
      
      
      
      
      
      <ul>











      
      
      
      
      
      
      
      
      
      
      </ul>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<br>











<h4>C) Updating the&nbsp;roboRIO Firmware</h4>











<p class="Body">For FRC 2017, the firmware version is the same as last
year: 3.0.0f0. &nbsp;You should not need to update the firmware unless
your roboRIO is new or has never been used for FRC. &nbsp;<span style="font-weight: bold;"></span>If
it is new,&nbsp;updating the firmware will make it
compatible with
the latest drivers installed by the roboRIO Imaging Tool. &nbsp;If you
are not sure if the firmware is up to date, you can follow steps 1-3
below to see the current version.</p>











<h4>Considerations Before Updating
the roboRIO Firmware</h4>











<ul>











  <li>It is recommended to run the roboRIO Imaging Tool prior to
updating the roboRIO firmware. &nbsp;Updating firmware may fail if
too much of the roboRIO disk space has been used. The Imaging Tool
formats the roboRIO prior to imaging, which frees up disk space.</li>











  <li>Do not update the roboRIO
firmware
over a wireless connection. If the connection is lost,
the&nbsp;firmware
will be&nbsp;corrupted and the roboRIO may require a factory
reset.&nbsp;</li>











  <li>Do not&nbsp;update the roboRIO
firmware over Ethernet.</li>











  <li>Your web browser will need to be able to run Microsoft
Silverlight which is supported by Internet Explorer and Firefox. &nbsp;It is not supported by Microsoft Edge.</li>











</ul>











<h4>Updating the&nbsp;roboRIO Firmware</h4>











Complete
the following steps to update the firmware on your roboRIO.
<ol>











  <li>Connect to the roboRIO over USB.</li>











  <li>Type 172.22.11.2 into your web browser.</li>











  <li>Click on Login. User name = Admin and password should be
left
empty (unless you have changed this).</li>











  <li>Select&nbsp;your roboRIO and press the <span style="font-weight: bold;">Update Firmware</span>
button.</li>











  <li>Navigate to and choose: C:\Program Files (x86)\National
Instruments\Shared\Firmware\cRIO\76F2\roboRIO_3.0.0f0.cfg.</li>











  <li>Press <span style="font-weight: bold;">Begin
Update</span> - you
should eventually see a "Transferring Firmware Image..."
message.&nbsp;
Give this a few minutes to complete.</li>











  <li>If you get a "Connection to Target Lost" message, ignore it
initially and it will likely close itself.</li>











  <li>The update is complete when the Firmware Revision shows
3.0.0f0.&nbsp; If it does not, and the Refresh button is live -
press it.</li>











</ol>











<br>











<br>











<hr><br>











<h2><a name="confignetwork">Tutorial
2—Setting up
the Robot Radio</a></h2>











<p class="Body">In 2017, the FRC Radio Configuration
Utility is an external tool provided by FIRST. The installer for this
utility can be found on <a href="https://usfirst.collab.net/sf/frs/do/listReleases/projects.wpilib/frs.frc_radio_configuration_utility">TeamForge</a>.</p>











<p class="Body">Complete
the steps in the following sections to
configure the radio.</p>




<h3><br>




</h3>




<h3>Configuring the Radio for
Competitions</h3>











<p class="Body">Complete
the following steps to configure a radio for
development.</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;At
official FRC events, you
must use the FRC Radio Kiosk at the inspection table to configure your
radio. You can download a team-use version of the radio configuration
kiosk on the <a href="http://digital.ni.com/express.nsf/bycode/FRC2011RadioConfig">FIRST
kit of parts Web page</a>.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<ol>











  <li>Launch the&nbsp;<span style="font-weight: bold;">Radio
Configuration
Utility</span> that you installed from TeamForge.</li>











  <li>In the <span style="font-weight: bold;">Network
Interfaces</span>
dialog of the utility, select the network interface (the Ethernet
port)&nbsp;your radio is connected to and press OK. <br>











    <br>











    <img style="width: 567px; height: 171px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/NetworkInterfacesRadio.gif"></li>











  <li>In the utility, enter your team number, choose your
radio type, and follow the directions. <br>











    <br>











    <img style="width: 624px; height: 492px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/RadioConfigurationUtility.gif"></li>











  <li>When you press Configure,
you should see a <span style="font-weight: bold;">Configuration
Progress</span>
dialog followed by a <span style="font-weight: bold;">Complete</span>
dialog.<br>











    <br>











    <br>











  </li>











</ol>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="configcamera">Tutorial
3—Setting up
the Axis Camera</a></h2>











<p class="Body">You must
configure the&nbsp;robot radio before configuring
the Axis
camera.</p>











<p class="Body">When you
configure the Axis camera,&nbsp;the
username and password of the camera are set to FRC so the Camera VIs
can
communicate with the camera. You need to configure the camera only once.</p>











<h3>Configuring the Axis camera</h3>











<ol>











  <li>Start with your Axis camera
set to its factory defaults - hold down the reset button on the back of
the camera and then plug in the power.&nbsp; Keep the button held
down until the lights on the camera face turn on and then release the
button.&nbsp;</li>











  <li>Connect the Axis camera to
the configured bridge with an Ethernet cable.</li>











  <li>Launch the&nbsp;<span style="font-weight: bold;">Setup
Axis
Camera Tool</span>
from the Utilities
tab of the LabVIEW Getting Started window.</li>











  <li>The tool will search for the
camera as the DHCP Server on the bridge sets the camera's IP Address.<br>











    <br>











    <img style="width: 607px; height: 383px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CameraSearch.gif"></li>











  <li>When the <span style="font-weight: bold;">Camera
found</span>
LED turns on, press the Apply button.<br>











    <br>











    <img style="width: 597px; height: 373px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CameraApply.gif"></li>











  <li>If your camera is not found, check that:</li>











  
  
  
  
  
  
  
  
  
  
  <ol>











    <li>the radio has&nbsp;been configured.</li>











    <li>both the radio and camera have power.</li>











    <li>there is an&nbsp;Ethernet cable from the camera to
the radio,
and from the radio to your development PC.</li>











  
  
  
  
  
  
  
  
  
  
  </ol>











  <li>The <span style="font-weight: bold;">Camera
not found?</span>
button will show a list of IP configurations on your PC. One of these
should be compatible with your radio.</li>











</ol>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of Contents</a>
<hr><br>











<br>











<br>











<h2><a name="devrobproj">Tutorial
4—Developing a
Robot Project</a></h2>











<p class="Body">The <em>FIRST</em>
Robotics Competition (FRC) projects
are sets of VIs, organized in a LabVIEW project, that you can use as a
template when building a robotics application. The FRC projects consist
of two project template types. Use the FRC robot project templates to
develop
the program you want to deploy to and run on the roboRIO. Use
the <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#dashboard">FRC
dashboard project</a> template to
develop
a program that allows you to view data on the host computer.</p>











<p class="Body">This
tutorial describes how to create, modify, and
deploy a robot project, also referred to as an FRC robot project, to
the roboRIO. In this tutorial, you develop a program to
perform arcade driving with a joystick and Talon motor controllers.</p>











<h4>Creating an FRC Robot Project</h4>











<p class="Body">Complete
the following steps to create an FRC robot
project.</p>











<ol>











  <li>Click the <strong>FRC
roboRIO Project</strong> link on
the Projects tab in
the <strong>Getting
Started</strong> window
to display
the <strong>Create New FRC Robot
Project</strong> dialog box, shown
as follows. <br>











    <br>











    <img alt="Create Robot Project" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/createrobotproj_dialog.gif" style="width: 603px; height: 439px;"> <br>











    <br>











  </li>











  <li>In the <strong>Project
name</strong> text box, enter the
name
you want to use to identify the new FRC robot project.</li>











  <li>In the <strong>Project
folder</strong> text box, enter the
location on the host machine to which you want to save the project
files and VIs.</li>











  <li>In the <strong>Team
number</strong> text box, replace
the xxyy
with your team number.&nbsp;</li>











  <li>Choose a robot project.
Note that all projects include simulation. &nbsp;Simulation
allows you to learn how to program your robot using LabVIEW without
having an actual robot. &nbsp;You do not need a roboRIO
controller to run simulation. Instead your code runs in the FRC
Simulation Viewer, where&nbsp;you can drive your robot to test your
code. &nbsp;The same code can be built into an executable to run on
your real robot. Refer
to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#simulation">Tutorial
10—Robot Simulation</a>
for more information about
using simulation.</li>











  <li>Click the <strong>Finish</strong>
button to close the <strong>Create
New FRC Robot Project</strong>
dialog box and create the new FRC robot
project.&nbsp;</li>











</ol>











<p class="Body">LabVIEW
displays the new FRC robot project in the <strong>Project
Explorer</strong> window, shown as
follows.</p>











<img alt="FRC Robot Project" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/FRC_Robot_Projects.gif" style="width: 395px; height: 506px;">
<p class="Body">Notice that
the FRC robot project contains two targets:
<strong>My Computer</strong>
and&nbsp;<strong>Target
(roboRIO-1959-FRC.local)</strong>.
Files under <strong>My Computer</strong>
are those you want to use and
run on the host computer. Files under the&nbsp;<strong>roboRIO
Target</strong>
are those you want to deploy to and run on the roboRIO.</p>











<p class="Body">The&nbsp;<strong>roboRIO Target</strong>
contains
one
top-level VI, the Robot Main VI, which is the master VI for the robot
and is the top-level VI for the robotics program you run on the
roboRIO. This target also contains a&nbsp;<strong></strong><strong>Team
Code</strong>
folder. This folder contains VIs that the Robot Main VI calls.</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;The
project that you create
also contains default code to drive a robot in Teleop mode. The default
code assumes the robot includes two motors and one joystick.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body">Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#editrobproj">Tutorial
5—Editing Team Code VIs</a>
for more information about the&nbsp;subVIs the FRC Robot Project
contains.</p>











<h3>Deploying the FRC Robot
Project to the roboRIO</h3>











<p class="Body">After you
develop the FRC robot project you want to
run, you must deploy the program to the roboRIO. You can
deploy the program in three ways: using the <strong>Run</strong>
button; from the <strong>Project
Explorer</strong> window; or as a
stand-alone, built application.</p>











<br>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp; Regardless
of how you deploy your
robot program, you must also be running the FRC Driver Station in order
for output (motors etc.) to work. &nbsp;The FRC Driver Station can
be
launched from the Start menu or from the Desktop shortcut.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<h4>Deploying the Program Using
the <strong>Run</strong>
Button</h4>











<p class="Body">When you
deploy a program with the <strong>Run</strong>
button, you maintain a connection between the host computer and the
roboRIO. The program runs on the roboRIO, but you
can manipulate the front panel objects of the program from the host
computer. You therefore can deploy a program with the <strong>Run</strong>
button to perform live front panel debugging.</p>











<p class="Body">Complete
the following steps to run the FRC robot
project and perform live front panel debugging.</p>











<ol>











  <li>In the <strong>Project
Explorer</strong> window,
double-click
the <strong>Robot Main.vi</strong>
item to open the Robot Main VI. <span style="font-weight: bold;">Tip</span>:
With Robot Main.vi open, it can be helpful to right-click on the lvproj
file in the Project Explorer window and choose <span style="font-weight: bold;">Save All (this Project)</span>.
This can speed up the download time by ensuring that Robot Main.vi and
all of its subVIs are saved prior to download.</li>











  <li>Click the <strong>Run</strong>
button of the Robot Main VI to
deploy the VI to the roboRIO. <br>











    <br>











LabVIEW deploys the Robot Main VI and any support files for the VI to
the roboRIO. The Robot Main VI then runs on the roboRIO. If the robot
has a joystick connected to port 1 of the driver
station and Talon motor controllers controlling the two wheels, you
can move the joysticks and observe how the robot responds.
&nbsp;Note
that for any robot output to work you must be running the Driver
Station in Teleop Enabled mode.</li>











  <li>Move the joystick and
observe how the robot responds.</li>











  <li>Click the <strong>Finish</strong>
button of the Robot
Main VI.
Notice that the VI stops.</li>











</ol>











<p class="Body">If you
click the <strong>Run</strong>
button of the
Robot Main VI and it
runs slowly, close any subVIs of the Robot Main VI that are open on the
host computer to improve performance. Do not close the Robot Main VI.</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;If
a program is running on
the roboRIO and you redeploy that program with the <strong>Run</strong>
button, the roboRIO stops and restarts the program you
deployed. LabVIEW redeploys any VIs that changed or are no longer in
memory on the roboRIO.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<h4>Deploying the Program from the
Project Explorer Window</h4>











<p class="Body">In the <strong>Project
Explorer</strong> window,
right-click the <strong>Robot
Main VI</strong> and select <strong>Deploy</strong>
from the shortcut menu to deploy the VI and any support files for the
VI to the target. When you deploy a program from the <strong>Project
Explorer</strong>
window, the program runs only on the roboRIO to which it was
deployed. Therefore, you cannot perform live front panel debugging.</p>











<h4>Building and Deploying a
Stand-Alone Application</h4>











<p class="Body">To run a
robot in competition, you must build the FRC
robot project into a stand-alone application that you deploy to the
roboRIO. You then can specify the application to run at
startup so the application runs as soon as the roboRIO is powered
on. </p>











<p class="Body">Complete
the following steps to build the FRC robot
project into a stand-alone application and run it on the roboRIO at
startup.</p>











<ol>











  <li>In the <strong>Project
Explorer</strong> window,
double-click
the <strong>FRC Robot Boot-up
Deployment</strong> build
specification
under the <strong>Build
Specifications</strong> folder to
display the <strong>FRC
Robot Boot-up Deployment Properties</strong>
dialog box.</li>











  <li>On the <strong>Information</strong>
page, the <strong>Build
specification name</strong>
text box specifies a name for the
build specification.</li>











  <li>The <strong>Target
filename</strong>
text box specifies a name for the
application.</li>











  <li>The <strong>Local
destination
directory</strong> text box specifies where you want to
save the stand-alone application on the
host computer .</li>











  <li>The <strong>Target
destination
directory</strong> text box specifies&nbsp;where you want
to save the stand-alone application&nbsp;on the
roboRIO.</li>











  <li>Select <strong>Source
Files</strong> from the <strong>Category</strong>
list.</li>











  <li>Verify that the Robot Main
VI is in the <strong>Startup VIs</strong>
list.</li>











  <li>Click the <strong>OK</strong>
button to close the <strong>FRC
Robot Boot-up Deployment Properties</strong>
dialog box.</li>











  <li>In the <strong>Project
Explorer</strong> window,
right-click the
build specification and select <strong>Build</strong>
from the
shortcut menu to build the application.</li>











  <li>After the build finishes,
right-click the build specification and
select <strong>Run as startup</strong>
from the shortcut menu to set
the application as the startup application and deploy the application
to the roboRIO. LabVIEW will restart on the RT target and your robot
code will start running.</li>











  <li>The application will run
each time you reboot the roboRIO.
&nbsp;When the roboRIO reboots, the STATUS light on it
momentarily turns on and then off. If you do not see the status light
turn on, you can reboot the roboRIO from the <strong>Diagnostics</strong>
page of the driver station. </li>











  <li>Ensure the driver station is
running and set to Teleop Enabled
mode.</li>











  <li>Move the&nbsp;joystick
and
observe how the motors of the robot
respond.</li>











  <li>If you no longer want the
application to run on the roboRIO at startup, perform these two steps:</li>











  
  
  
  
  
  
  
  
  
  
  <ol>











    <li>Right-click the build
specification and select <strong>Unset
as startup</strong> from the
shortcut menu.</li>











    <li>Right-click on Robot
Main.vi and choose <span style="font-weight: bold;">Deploy</span>
from the shortcut menu..</li>











  
  
  
  
  
  
  
  
  
  
  </ol>











</ol>











<h4>Connecting to the roboRIO</h4>











<p class="Body">If you stop
the VI or close the front panel, the VIs
are no longer running on the roboRIO. However, if you only
disconnect from the roboRIO, the front panel on the host
computer appears to stop, but the VI continues running on the roboRIO.
Right-click the&nbsp;<strong>Target
(roboRIO-1959-FRC.local)</strong>
item in the <strong>Project
Explorer</strong> window and select <strong>Disconnect</strong>
from the shortcut menu to disconnect from the roboRIO. If you
then close the front panel and reconnect to the roboRIO, you
re-access the front panels in memory on the device. The front panel of
the running VI reappears and displays the current state of the VI.
Right-click the&nbsp;<strong>Target
(roboRIO-1959-FRC.local)</strong> item
in
the <strong>Project
Explorer</strong> window and select <strong>Connect</strong>
from the
shortcut menu to connect to the roboRIO.
You cannot access the front panels of VIs in memory on a roboRIO if a
built application is running. You first must stop the
running built application or cancel the Connect operation.</p>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="editrobproj">Tutorial
5—Editing Team
Code VIs</a></h2>











<p class="Body">Use the
following VI descriptions to learn which VIs
you want to edit to write the program you want to run on the robot.</p>











<p class="Body">The <strong>RT
roboRIO Target</strong> contains
one
top-level VI, the Robot Main VI, which is the master VI for the robot
and is the top-level VI for the robotics program you run on the
roboRIO. This target also contains a&nbsp;<strong></strong><strong>Team
Code</strong>
folder. This folder contains VIs that the Robot Main VI calls.</p>











<h4>Robot Main VI</h4>











<p class="Body">The Robot
Main VI establishes communication with the
driver station, acquires and processes images, and performs Autonomous
or Teleop tasks depending on the mode.</p>











<p class="Body">In the <strong>Project
Explorer</strong> window,
double-click the <strong>Robot
Main.vi</strong> item to open the
Robot
Main VI. Select <strong>Window»Show
Block Diagram</strong> or
press the &lt;Ctrl-E&gt; keys to view the block diagram. The
block
diagram contains a single While Loop and a number of subVIs. The While
Loop determines the behavior of the robot according to the mode and
call context. When the mode is Autonomous Enabled, the Robot Main VI
calls the Autonomous Independent VI. When the state is Teleop Enabled,
the Robot Main VI calls the Teleop VI. If the robot is in Disabled
status, the Robot Main VI calls the Disabled VI.</p>











<p class="Body">Robot Main
also contains the NT Server
VI, which starts the server for Network Tables. This server makes it
easy to pass data back and forth between your robot code and dashboard
code using the&nbsp;Dashboard VIs. Refer to&nbsp;the&nbsp;<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#teleopVI">Teleop VI</a>
section for more information about the&nbsp;Dashboard&nbsp;VIs.</p>











<p class="Body">The other
subVIs in the Robot Main VI execute tasks
such as initializing data, performing time-based operations, and
processing images.</p>











<p class="Body">After the
Robot Main VI calls the Begin subVI, it uses
the Start Communication VI to establish communication with the driver
station. The Robot Main VI runs until the <strong>Abort
Execution</strong>
button on the VI toolbar is pressed or until the <strong>Finish</strong>
button on the front panel is pressed. If the <strong>Abort
Execution</strong>
button is pressed, the Robot Main VI aborts immediately and does not
perform any cleanup tasks. If the <strong>Finish</strong>
button is
pressed, the Robot Main VI calls the Finish VI, which you can configure
to close device references, save collected data to file, or perform any
other cleanup tasks.</p>











<p class="Body">You can
modify the code within each of the VIs in the <strong>Team
Code</strong> folder of the robot
project.</p>











<h4>Team Code VIs</h4>











<p class="Body">The <strong>Team
Code</strong> folder of the FRC
robot
project contains subVIs that the Robot Main VI calls to perform the
initialization, execution, and cleanup tasks for the Autonomous and
Teleop modes.</p>











<p class="Body"><strong><a name="beginVI">Begin
VI</a></strong></p>











<p class="Body">The Begin
VI initializes data for use throughout the
Robot Main VI. You can create references to motors and sensors you want
to use, load settings from file, and perform other initialization tasks.</p>











<p class="Body">By default,
the Begin VI opens a&nbsp;reference for two motors, and opens a
reference for one
joystick. You can use the WPI Robotics Library VIs and other LabVIEW
VIs to configure other initialization tasks.</p>











<p class="Body">Create all
references you want to reuse in the Begin VI
before you develop the programs you want to run on the robot. Complete
the following steps to create a reference.</p>











<ol>











  <li>In the <strong>Project
Explorer</strong> window of the FRC
robot
project, within the <strong>Team
Code</strong> folder under the&nbsp;<strong>roboRIO
Target</strong>,
double-click the <strong>Begin.vi</strong>
item to open the Begin VI. &nbsp;Alternatively you can double-click
the <span style="font-weight: bold;">Begin.vi</span>
from the diagram
of Robot Main.vi.</li>











  <li>Select <strong>Window»Show
Block Diagram</strong> or press
the &lt;Ctrl–E&gt; keys to view the block diagram.</li>











  <li>Notice that the code already
opens and registers references for&nbsp;Left
and Right Motors and Joystick 0. <br>











    <br>











Similarly, you can open and register references for any other sensor or
actuator.
Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#exampleprog">Tutorial
7—Integrating Examples
into Robot Code</a> for information
about adding a reference for a
gyroscope. </li>











</ol>











<p class="Body">After you
set references in the Begin VI, use the
RefNum Registry Get VIs to reuse the references in other VIs that you
create.</p>











<p class="Body"><strong>Autonomous
Independent VI</strong></p>











<p class="Body">The
Autonomous Independent VI runs while the robot is
in the Autonomous mode. You do not need to program the Autonomous
Independent VI to stop after a certain time because the Robot Main VI
terminates this VI when the mode changes to Teleop.</p>











<p class="Body">The block diagram of the Autonomous
Independent VI contains a Case structure. The Default case has no code
-&nbsp;this is where you might use the WPI
Robotics Library VIs and other LabVIEW VIs to specify the program you
want to run while the robot is in the Autonomous mode. &nbsp;The Case
structure also has predefined cases "Alternative 1" and "Alternative
2". &nbsp;You might decide to edit the code in these cases and then
choose which one to run from the menu that already exists on the
Dashboard. &nbsp;When the Dashboard is running, and you run your robot
code, the Dashboard menu will be loaded with the <span style="font-weight: bold;">Alternative 1</span> and <span style="font-weight: bold;">Alternative 2</span>
choices. &nbsp;While the code for this Autonomous menu is already
written for you, understanding the design will help you when editing:</p>






<ol>






  <li>If you look at the diagram of the Begin VI, you will notice there is an <span style="font-weight: bold;">NT Write String Array</span> VI that writes Alternative 1 and Alternative 2 to a Network Table array named <span style="font-weight: bold;">Auto List</span>. &nbsp;If you wanted to add to or edit the menu names seen in the Dashboard, you just need to edit this array.</li>






  <li>The Dashboard reads <span style="font-weight: bold;">Auto List</span>
to populate its menu. &nbsp;The code for this exists on the Dashboard
diagram within the Event Structure, but does not need to be edited.
&nbsp;When you make a choice in the Dashboard menu, it writes your
choice to a Network Table string named <span style="font-weight: bold;">Auto Selector</span>. &nbsp;This&nbsp;is also code in the Event Structure of the Dashboard that does not need to be edited.</li>






  <li>Back in the Autonomous Independent VI your Dashboard menu choice is read from the Network Table string named <span style="font-weight: bold;">Auto Selector</span> and passed to the selector of the Case structure to choose which autonomous code to run.<span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></li>






</ol>











<strong>Disabled VI</strong>
<p class="Body">The
Disabled VI runs each time the program receives a
disabled driver station packet. You can use the Disabled VI to
calibrate sensors or the Axis camera.</p>











<p class="Body"><strong><a name="teleopVI"></a>Teleop
VI</strong></p>











<p class="Body">The Teleop
VI iterates and performs some action each
time a packet specifying the Teleop mode arrives from the driver
station.</p>











<p class="Body">The block
diagram of the Teleop VI contains basic code
to read values from a joystick and update the robot motors. It also
contains code to publish&nbsp;data to the dashboard and read data
from
the dashboard. Edit this
code or add your own code to drive the robot. If you want to add
initialization or clean up code, use the Call Context input terminal to
control a Case
structure with Init, Execute, and Stop cases.</p>











<p class="Body">The Teleop
VI uses one or more of the references you
set in the Begin VI to specify device references of the correct data
types for use with the WPI Robotics Library VIs. Refer to the <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#beginVI">Begin VI</a>
section for information about creating
references.</p>











<p class="Body">For
dashboard communication, the Teleop VI uses the NT
Write VIs to send data to the dashboard. The Name wired into these VIs
must match the Name used in the dashboard code. &nbsp;The NT Read
VIs
are used to read data from the dashboard. Here the Names wired in match
names of controls on the Custom tab of the Dashboard Main VI. Any
control placed on the&nbsp;Custom tab of the Dashboard Main VI gets
registered with the Network Tables server and can be read using NT Read
VIs in the robot code.</p>











<p class="Body"><strong>Robot
Global Data VI</strong></p>











<p class="Body">Use the
Robot Global Data VI to access and pass data
among several VIs.</p>











<p class="Body">Because
global VIs only pass data and perform no
computations, global VIs contain a front panel but no block diagram. By
default, the Robot Global Data VI contains an <strong>Enable
Vision</strong>
front panel control.</p>











<p class="Body">On the
block diagram of the Vision Processing VI, the <strong>Enable
Vision</strong> global variable is
wired to the Case structure that
determines whether to start or stop image acquisition. The value of the
<strong>Enable Vision</strong>
control in the Robot Global Data VI
determines which case of the Case structure in the Vision Processing VI
to execute. For example, you can set the <strong>Enable
Vision</strong>
global variable to True or False, depending on a joystick button that
is read in the Teleop VI. Using the variable this way allows you to
turn vision on or off by pressing a joystick button.</p>











<p class="Body"><strong>Vision
Processing VI</strong></p>











<p class="Body">The Vision
Processing VI acquires images from the&nbsp;camera and performs image processing. This VI runs continuously while
the Robot Main VI is running.</p>











<p class="Body">The block
diagram of the Vision Processing VI consists
of initialization code followed by a While Loop, which itself contains
a Case structure. The Case
structure determines whether to start or stop acquiring image data from
the&nbsp;camera and whether to process the images.</p>











<p class="Body">Notice the <strong>Enable
Vision</strong> global
variable that is wired to the Case structure. This global variable is
an instance of the Robot Global Data VI. The value of the <strong>Enable
Vision</strong> control is set in
the Robot Global Data VI and then
passed to the Case structure.</p>











<p class="Body">If the <strong style="font-weight: normal;"><span style="font-weight: bold;">Enable
Vision</span> global</strong>
variable
is TRUE, the True case of the Case structure executes. Therefore, the
Vision Processing VI acquires image data from the&nbsp;camera,
retrieves specific images from this data, and processes each image. You
can use the FIRST Vision VIs to process the image data. If the <strong>Enable
Vision</strong> global variable is
FALSE, the Vision Processing VI
neither acquires nor processes any images from the camera.</p>











<p class="Body">You might
use image processing to help determine the
behavior of a robot. For example, you can use the FIRST Vision VIs to
determine the color of an image you acquire. Depending on the color,
you then can move the motors of the robot in an appropriate direction.</p>











<p class="Body">If you do
not want to perform image acquisition
continuously, you can configure the <strong>Enable
Vision</strong>
control in the Robot Global Data VI to change value depending on the
mode, for example.</p>











<p class="Body"><strong>Periodic
Tasks VI</strong></p>











<p class="Body">The
Periodic Tasks VI performs&nbsp;tasks at specified time intervals.
For
example, you might include PID VIs to perform time-based control
operations. This VI runs continuously while the Robot Main VI is
running.</p>











<p class="Body">By default,
the block diagram of the Periodic Tasks VI
consists of two While Loops. Each While Loop contains a Wait (ms)
function that specifies the length of time to wait between each
iteration of the loop. You can change the value of the <strong>milliseconds
to wait</strong> input to specify
the frequency of each periodic task.</p>











<p class="Body">Periodic
loops often operate with setpoints from other
loops. Use a global variable such as the Robot Global Data VI to share
data among loops.</p>











<p class="Body">The
Periodic Tasks VI uses one or more of the
references you set in the Begin VI to specify device references of the
correct data types for use with the WPI Robotics Library VIs. Refer to
the <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#beginVI">Begin
VI</a> section for information about
creating references.</p>











<strong>Finish
VI</strong>
<p class="Body">The Finish
VI performs cleanup tasks before the Robot
Main VI stops. This VI runs when you press the <strong>Finish</strong>
button on the front panel of the Robot Main VI. This VI does not get
called during competition.</p>











<p class="Body">The block
diagram of the Finish VI contains a Flat
Sequence structure. In the first subdiagram of this structure, you can
perform cleanup tasks such as closing device references and saving
collected data to file. The second subdiagram of the Flat Sequence
structure stops the Finish VI and, in turn, the Robot Main VI.</p>











<p class="Body">The Finish
VI uses one or more of the references you
set in the Begin VI to specify device references of the correct data
types for use with the WPI Robotics Library VIs. Refer to the <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#beginVI">Begin VI</a>
section for information about creating
references.</p>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a>
<hr><br>











<br>











<h2><a name="dashboard">Tutorial
6—Creating a
Custom Dashboard</a></h2>











<p class="Body">Use the FRC
dashboard project on the host computer to
create a custom dashboard that allows you to view data that the roboRIO
returns. This project can display images and I/O
values that the roboRIO sends to the host computer.</p>











<p class="Body">Complete
the following steps to create an FRC dashboard
project.</p>











<ol>











  <li>Click the <strong>FRC
Dashboard Project</strong> link on
the Projects tab in
the <strong>Getting
Started</strong> window to display
the <strong>Create New FRC
Dashboard Project</strong> dialog
box, shown as follows. <br>











    <br>











    <img style="width: 603px; height: 439px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/createdashproj_dialog.gif" alt="Create Dashboard Project"> <br>











    <br>











  </li>











  <li>In the <strong>Project
name</strong> text box, enter the
name
you want to use to identify the new FRC dashboard project.</li>











  <li>In the <strong>Project
folder</strong> text box, enter the
location on the host machine to which you want to save the project
files and VIs.</li>




  <li>Choose a dashboard project. &nbsp;<span style="font-weight: bold;">Dashboard</span> is the&nbsp;project used to create the prebuilt dashboard. &nbsp;<span style="font-weight: bold;">Dashboard Simple</span>
is a new project with less features. &nbsp;If you don't need all the
features of the prebuilt dashboard such as multiple cameras, the Test
tab, and Commands tab, this may be an easier project to edit.</li>











  <li>Click the <strong>Finish</strong>
button to close the <strong>Create
New FRC Dashboard Project</strong>
dialog box and create the new FRC
dashboard project. LabVIEW displays the new FRC dashboard project in
the <strong>Project Explorer</strong>
window.</li>











</ol>











<p class="Body">The FRC
dashboard project looks similar to the
following figure:</p>











<img style="width: 395px; height: 329px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/FRC_Dashboard_Project.gif" alt="FRC Dashboard Project">
<p class="Body">Whereas the
FRC robot project contains two targets, the
FRC dashboard project contains only the <strong>My
Computer</strong>
target. You run the VIs in the FRC dashboard project only on a host
computer. You do not deploy these VIs to the roboRIO.</p>











<p class="Body">The <strong>My
Computer</strong> target contains a
Dashboard Main top-level VI and a <strong>Support</strong>
folder.
The <strong>Support</strong>
folder contains VIs that the
Dashboard Main VI calls. You might not need to modify any of the VIs in
this folder.</p>











<p class="Body">The
Dashboard Main VI is the master VI in the FRC
dashboard project. You can use this VI on the host computer to view
image data that the camera connected to the roboRIO acquires.</p>











<p class="Body">You also
can use the Dashboard Main VI to read
information about the robot, such as motor drive values, battery level,
and any other data you want to send from the robot.
In the <strong>Project Explorer</strong>
window, double-click the <strong>Dashboard
Main.vi</strong> item to open the
Dashboard Main VI. By default, the
front panel displays the following information:</p>











<ul>











  <li>Camera Image—The
left panel of the dashboard displays the
latest image that the camera on the roboRIO acquired. The drop down
menu control shows a list of connected cameras to choose from. &nbsp;If no cameras are connected, this list will be empty.</li>




  <li>Displaying the camera
image&nbsp;might slow performance. Use the
control next to the camera menu<span style="font-weight: bold;"></span>
to configure the dashboard
video. By using a smaller image size, slower <span style="font-weight: bold;">Frame Rate</span>
and higher <span style="font-weight: bold;">Compression</span>,
video performance can
be improved.</li>











  <li>Drive tab—Displays
axis and button information for
two joysticks, and drive output information for up to four motors.</li>




  <li>Camera tab - adds the ability to show a second camera.</li>











  <li>Basic tab - Displays string
message and LED values you can send
from the robot. &nbsp;It also contains Boolean button and numeric
slider controls. &nbsp;The values of these controls can be read
from
the robot using Smart Dashboard VIs.</li>











  <li>Custom
tab—Displays controls and indicators. Customize this
tab with your own controls and indicators, and
then&nbsp;write and read&nbsp;data to and from your robot code.
&nbsp;Any
control or indicator on the Custom
tab gets a variable automatically created with the control or indicator
name used as the variable name.</li>











  <li>Test tab—Displays
input and output values for all registered references, and allows you
to individually test I/O points. The Driver Station must be in Test
mode in order for this tab to work.</li>











  <li>Commands tab—Displays a list of commands, and
allows you to test commands. &nbsp;This is for use with the Command
&amp; Control template.&nbsp;The Driver Station must be in Test
mode in order for this tab to work.</li>











  <li>Checklist
tab—Displays a&nbsp;list of
robot&nbsp;competition
items to be checked before running a match. &nbsp;You can customize
this list to fit your needs.</li>











  <li>Variables
tab—Displays
Network Table variables, TestMode variables, and Usage information for
the Client and Server of the variables.</li>











</ul>











<p class="Body">Select <strong>Window»Show
Block Diagram</strong>
or press the &lt;Ctrl–E&gt; keys to view the block
diagram of the
Dashboard Main VI. The block diagram contains three While Loops you may choose to edit.</p>











<p class="Body">In Loop 1,
the Dashboard Main VI
receives data about the robot from the driver station. By default, the
Dashboard Main VI connects to the driver station through TCP and UDP
connections and receives data about the robot. This data includes <span style="font-weight: bold;">Status Info</span>, <span style="font-weight: bold;">Control Info</span>, <span style="font-weight: bold;">Robot Metrics</span>, and <span style="font-weight: bold;">Power and Errors</span> information that can be used by the dashboard. &nbsp;This loop
is also used to read Network Table variables from the robot. Notice
that "RobotDrive Motors", the&nbsp;string constant value wired to the Name input of
the NT
Read VI, exactly matches that used for the NT Write VI in the Teleop VI
of the robot code.</p>











<p class="Body">In Loop
2,&nbsp;the Dashboard Main VI retrieves
specific images on the host computer from the image data that either
the
roboRIO sends, or that is sent directly via the robot radio.&nbsp;
The
Dashboard Main VI creates a
JPEG image, continuously replaces this image
with the most recent image data from the camera, and
displays the image in the Image indicator on the front
panel. &nbsp;By default,&nbsp;camera image acquisition is off -
you
must choose your connected camera type from the front panel menu.</p>











<p class="Body">Loop 2.5&nbsp;adds the ability to show images from a second camera.</p>




<p class="Body">Below Loop
2.5 is code that typically does not need to be
modified. &nbsp;There are terminals for Test Mode,&nbsp;Camera
Settings, the Basic tab, etc. &nbsp;There are also additional loops
whose purposes are described on the diagram itself.</p>











<p class="Body">You can use
the WPI Robotics Library VIs and other
LabVIEW VIs to modify the types of data the Dashboard Main VI displays.</p>











<h3>Modifying the FRC Dashboard
Project</h3>











<p class="Body">The
Dashboard Main VI in the FRC Dashboard Project
displays information about the robot. You can use the Dashboard Main
VI&nbsp;to receive live feedback from the robot. The Dashboard
Main VI also displays user-defined data and the&nbsp;input and
output values from the roboRIO, the robot, and the driver
station.&nbsp;Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#exampleprog">Tutorial
7—Integrating Examples into Robot Code</a>
for information about
modifying the dashboard project.</p>











<h3>Rebuilding the FRC Dashboard
Project</h3>











<p class="Body">After you
customize the FRC Dashboard Project, you must
rebuild the project so that the Driver Station launches the most recent
version of the project.</p>











<p class="Body">Complete
the following steps to rebuild the project and
specify which project the Driver Station launches automatically.</p>











<ol>











  <li>In the <strong>Project
Explorer</strong> window of
the&nbsp;Dashboard Project, expand the list
of Build Specifications to reveal
the FRC_Dashboard application.</li>











  <li>Right-click <strong>FRC_Dashboard</strong>
and select <strong>Properties</strong>
from the shortcut menu. If the <strong>Application
Builder Information</strong>
dialog box appears, click <strong>OK</strong>.</li>











  <li>Verify that the <strong>Target
filename</strong> is <span class="Monospace">Dashboard.exe</span>.
The Driver Station reads this
executable file as the file to launch.</li>











  <li>Verify that the <strong>Destination
directory</strong> is where
you want to save the file. Click <strong>Build</strong>
to build the
new project.</li>











  <li>Explore to where you saved
the new executable file. Copy the new
Dashboard.exe file&nbsp;to the&nbsp;<span class="Monospace">FRC Dashboard</span> folder within&nbsp;<span class="Monospace">Program
Files.</span> &nbsp;You may want to save a backup of the original Dashboard.exe that installed in that folder.<span class="Monospace"><span class="Body"></span></span></li>











</ol>











<p class="Body"><br>











</p>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="exampleprog">Tutorial
7—Integrating
Examples into
Robot Code</a></h2>











<p class="Body">Use the FRC
examples to better understand how to read
robot
sensors or control robot actuators. This tutorial uses the Gyro Example
to demonstrate how to incorporate example program code into your robot
code.</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;If
you are not familiar with
the Team Code VIs such as the Begin VI and Teleop VI, refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#editrobproj">Tutorial 5: Editing Team Code VIs</a>
before
completing this tutorial about integrating examples.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body">By default,
the robot project does not acquire
gyroscope data, and the dashboard does not display gyroscope data.
Complete the following procedures to integrate the Gyro Example into
your robot code so that the robot acquires gyroscope (gyro) data and
sends the data to the dashboard. You can then edit the dashboard code
to display the data.</p>











<h3>Part 1—Integrating
the Gyro Example Code to Read Gyro Data</h3>











<p class="Body">First, you
must open the example you want to use.
Complete the following steps to open the Gyro Example.</p>











<ol>











  <li>On the <span style="font-weight: bold;">Support</span>
tab of
the <strong>Getting
Started</strong> window, click the <strong>Find
FRC Examples</strong> link to
display the NI Example Finder.</li>











  <li>Under the <strong>FRC
Robotics&gt;&gt;roboRIO</strong>
folder,
double-click the <strong>Sensors</strong>
folder to view sensor examples.</li>











  <li>Double-click&nbsp;<strong>XRS450 SPI Gyro.lvproj</strong>
to open the
example project.</li>











  <li>In the <strong>roboRIO
(172.22.11.2)</strong>
section,
double-click the&nbsp;<strong>XRS450 SPI Gyro.vi</strong>
item to open the
VI.</li>











</ol>











<p class="Body">Notice that
the front panel of the VI shows the SPI Bus the VI uses, as
well
as the Sample Rate. &nbsp;It also shows how to wire the gyro to
your roboRIO, which in this case simply plugs into the SPI port. If you
have not used a gyro
before, first ensure that
you can run this example VI successfully. This example expects that you
have the&nbsp;Gyro &amp; Accel sensor board provided by Analog
Devices.<br>











</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;If
you do not have this sensor, you could also follow this tutorial using
an analog gyro and the Analog Gyro.lvproj example.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body"> &nbsp;The block diagram of&nbsp;<strong>XRS450
SPI Gyro.vi</strong> should
appear similar to the following figure.</p>











<img style="width: 848px; height: 359px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro example.gif">
<p class="Body">To
integrate the example code into the robot code, you
need to understand what each section of the code does. In general,
everything to the left of the loop is for configuration and belongs in
the Begin VI. Everything inside the loop reads data, performs
calculations and belongs in the Teleop, Autonomous, or Periodoc Tasks
VI. Finally,
everything to the right of the loop stops and releases resources and
belongs in the Finish VI.</p>











<p class="Body">Before you
integrate the example code, you can remove
the robot code that you no longer need:</p>











<ul>











  <li>Because the robot template
handles driver station communication,
you can remove the Start Communication VI, <img style="width: 32px; height: 32px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/Start Communications.gif">, and the
Stop primitive, <img style="width: 32px; height: 32px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/Stop.gif">.</li>











</ul>











<ul>











  <li>Because the robot template
handles looping and timing, you do not
need the While Loop, <strong>stop</strong>
terminal, or loop delay.</li>











  <li>Because the robot template
does error handling, you do not need
the <strong>status</strong>
output.</li>











  <li>For simplicity you also can
remove the gyro reset code. However,
after you get all of the new code working, you may want to add the gyro
reset code back. You could also control the reset with a joystick
button.</li>











</ul>











<p class="Body">The
following figure shows the code you still need to
integrate.</p>











<img style="width: 856px; height: 206px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro base code.gif"><br>











<br>











<p class="Body">You split
the remaining code into the Begin, Teleop,
and Finish
VIs of your robot code. However, notice there is a common wire among
all three subVIs—the RefNum wire. The Begin VI creates the
RefNum
wire, and you want the RefNum in the Teleop and Finish VIs. You need a
way to pass the RefNum between these VIs without the wire. To use the
RefNum in all three VIs, use the RefNum Registry Set VI, <img style="width: 32px; height: 32px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro refnum registry set.gif">, and
the RefNum
Registry Get VI, <img style="width: 32px; height: 32px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro refnum registry get.gif">.
You can find these VIs on each WPI Robotics Library palette. If you use
the RefNum
Registry VIs, you can now remove the RefNum Wire, as shown in the
following figure.</p>











<br>











<img style="width: 856px; height: 218px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro code split.gif">
<p class="Body">Notice that
the RefNum Registry VIs require a refnum
name. In this example, the name is <span style="font-weight: bold;">main
gyro</span>. You can choose any name
you want for the
RefNum Registry Set VI, but you must ensure that you wire the exact
same name to the RefNum Registry Get VI. At this point each section of
the example code is independent and ready for integration into your
robot code. The following sections describe how this code might look in
the Begin,
Teleop, and Finish VIs.</p>











<h4>Begin VI</h4>











<p class="Body">Add the
gyro configuration code to the
block diagram of the Begin VI. Place the code below the existing
joystick
configuration code. Your block diagram should appear similar to the
following figure.</p>











<img style="width: 309px; height: 260px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro begin.gif"><br>











<br>











<p class="Body">Notice that
you must replace the control terminals with
constant values. You do not have to change these values after you wire
the physical components of the robot. Ensure that these values make
sense for your hardware and application. &nbsp;For example, you may
not need to run your gyro at a sample rate of 1 ms depending on your
application.<strong></strong></p>











<h4>Teleop VI</h4>











<p class="Body">Add the
code to read the gyro angle.
Place the code somewhere below the existing joystick and drive code.
Your block
diagram should appear similar to the following figure.</p>











<img style="width: 535px; height: 300px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro teleop.gif">
<br>











<p class="Body">The <strong>Angle</strong>
indicator is not useful in
the Teleop VI because you cannot view the front panel of the Teleop VI
while the robot is running. Instead, you can send the angle data to the
dashboard where you can see it while the robot is running, so that
you can use the angle data to help you drive the robot. &nbsp;Part 2 of this example shows how to do this.</p>











<h4><br>











</h4>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;You
may want to add the gyro read code to&nbsp;<span style="font-weight: bold;">Periodic Tasks VI</span>
instead of <span style="font-weight: bold;">Teleop VI</span>.
Two reasons for this include:<br>











      
      
      
      
      
      
      
      
      
      
      <ol>











        <li>To avoid adding more code to <span style="font-weight: bold;">Teleop</span> in order to
make sure the teleop code runs within the expected 20 ms window.</li>











        <li><span style="font-weight: bold;">Periodic
Tasks</span> is always running, and you could wire the gyro angle
to a global variable making it always available to other parts of your
code includeing <span style="font-weight: bold;">Teleop</span>
and <span style="font-weight: bold;">Autonomous</span>.</li>











      
      
      
      
      
      
      
      
      
      
      </ol>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<h4>Finish VI</h4>











<p class="Body">Add the
gyro close code&nbsp;to stop and release
resources after the code
runs. The block diagram should appear similar to the following figure.</p>











<img style="width: 350px; height: 200px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro finish.gif">
<br>











<p class="Body">The code
does not call the Finish VI during a
competition because the Field Management System (FMS) disables all
robots at the end of a competition, and then teams typically reboot the
robots. Therefore, you do not need to use the Finish VI to stop and
release resources during a competition. However, when you develop code
and test the robot, you want to call the Finish VI to stop and release
resources after each time you run the code. You can call the Finish VI
by pressing the <strong>Finish</strong>
button in the Robot Main VI.
Using the Finish VI and the <strong>Finish</strong>
button allow you
to run the Robot Main VI multiple times without rebooting the robot
each time.</p>











<p class="Body">At this
point the robot code includes the gyro example
code. You can build and deploy the code to use the gyro. Similarly, you
can integrate other example VIs by following these same basic
steps.</p>











<h3>Part 2—Edit the
Robot Code to Send the Gyro Data to the
Dashboard</h3>











<p class="Body">In Part 1
you integrated the gyro code into the robot
code, so that the robot code reads the gyro data. Next, you can edit
the
robot code to pass the&nbsp;gyro angle to the
dashboard.</p>











<p class="Body">The<span style="font-weight: bold;">
Dashboard</span>
palette includes VIs to read and write Network Table variables. These
VIs make it easy to pass data back and forth between the robot and the
dashboard.</p>











<p class="Body"><img style="width: 223px; height: 198px;" alt="Dashboard palette" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/dashboard_palette.gif"></p>











At this
point, the robot code reads the gyro angle in the Teleop VI, so you
can send the gyro data from the Teleop VI to the dashboard. Complete
the following steps to send the gyro data to the dashboard.
<ol>











  <li>Right-click in a blank space
on the Teleop VI block diagram and
navigate to the NT Write Value VI on
the <strong>WPI Robotics
Library»Dashboard</strong><span style="font-weight: bold;"> </span>palette.
Add the NT Write Value VI
to the right of the <strong style="font-weight: normal;">Angle</strong>
terminal on the block
diagram of the Teleop VI. &nbsp;By default the NT Write Value VI
will
be configured to write a Boolean value - click on the drop down
selector menu on the VI and choose <span style="font-weight: bold;">NT
Write Number</span>.</li>











  <li>Right-click on the <span style="font-weight: bold;">Name</span>
input of the NT Write Number VI and choose <span style="font-weight: bold;">Create&gt;&gt;Constant</span>
from the
menu. Type 'Robot Angle' for the string constant value.</li>











  <li>Delete the Angle terminal,
and then wire the broken wire to the&nbsp;<strong>Numeric</strong>
input of the NT Write Number VI.</li>











</ol>











<p class="Body">The block
diagram should appear similar to the
following figure.</p>











<br>











<img style="width: 529px; height: 328px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro to dashboard.gif"><br>











<p class="Body">At this
point, the robot code reads the gyro data and
then sends the gyro angle to the dashboard each time&nbsp;the
Teleop VI is called. For this example we are writing a numeric value,
but notice in the selector menu of the VI that there are also choices
for writing and
reading string and Boolean data as well as arrays of data.<br>











</p>











<h3>Part 3—Editing the
Dashboard to Display the Gyro Angle While
the Robot is Running</h3>











<p class="Body">This
section assumes that you understand <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#dashboard">Tutorial
6—Creating a
Custom Dashboard</a>. From within
the Dashboard Project, open the
Dashboard
Main VI. Notice that a Gyro indicator already exists on the Drive tab.<strong></strong></p>











<br>











<img style="width: 540px; height: 370px;" alt="Dashboard Gauge" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/dashboard_gauge.gif"><br>











<br>











<p class="Body">Find the
Gyro terminal on the diagram of the Dashboard
Main VI in Loop 1. &nbsp;Complete the following steps to read the
gyro
data sent from the Teleop VI<br>











</p>











<ol>











  <li>Right-click in the blank
space on the Dashboard Main VI block
diagram and
navigate to the NT Read Value VI on
the <strong>WPI Robotics
Library»Dashboard</strong><span style="font-weight: bold;"> </span>palette.
Add the NT Read Value VI
to the left of the Gyro<strong style="font-weight: normal;"></strong>
terminal in the True case within Loop 1 on the block
diagram of the&nbsp;Dashboard Main VI. &nbsp;By default the NT
Read
Value VI will
be configured to read a Boolean value - click on the drop down
selector menu on the VI and choose&nbsp;<span style="font-weight: bold;">NT
Read Number</span>.</li>











  <li>Right-click on the <span style="font-weight: bold;">Name</span>
input of the NT Read Number VI and choose <span style="font-weight: bold;">Create&gt;&gt;Constant</span>
from the
menu. Type 'Robot Angle' for the string constant value. &nbsp;Note
that
this string constant must exactly match the string constant in your
Teleop code.</li>











  <li>Wire the&nbsp;<strong>Numeric</strong>
output of the&nbsp;SD Read Number VI to the Gyro terminal.</li>











</ol>











<p class="Body"></p>











<img style="width: 248px; height: 105px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/gyro read data.gif"><br>











<br>











<p class="Body">Now, you
can rebuild and deploy the robot project as
shown in <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#devrobproj">Tutorial
4—Developing a Robot Project</a>,
and rebuild the dashboard
project as shown in <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#dashboard">Tutorial
6—Creating a
Custom Dashboard</a>, to see the
gyro angle in the dashboard while you
drive you robot.</p>











<p class="Body"></p>











<h3>Using the Dashboard Custom Tab
for Easier Programing</h3>











<p class="Body">The
Dashboard has some built-in code that makes it
easier to read and write Network Tables data. &nbsp;By default,
any
control or indicator you place on the Custom tab will automatically be
associated with a Network Tables read or write. &nbsp;Controls
placed
on the Custom tab will write their values to the Network Tables
server. &nbsp;Indicators placed on the Custom tab will read values
from
the&nbsp;Network Tables server. &nbsp;The&nbsp;Network
Tables&nbsp;name
associated with the read or write is the same as the label name of the
control or indicator.</p>











<p class="Body">For example
if you place a numeric slide control on the
Custom tab of the Dashboard Main VI with its default label of <span style="font-weight: bold;">Slide</span>,
then you could use the NT
Read Value VI from
the <strong>WPI Robotics
Library»Dashboard</strong><span style="font-weight: bold;"> </span>palette
on the robot to read that value. &nbsp;You would simply use <span style="font-weight: bold;">Slide</span>
as the <span style="font-weight: bold;">Name</span>
input of the NT Read Number VI.</p>











<p class="Body">If you
place a numeric indicator on the Custom tab of
the Dashboard Main VI with its default label of&nbsp;<span style="font-weight: bold;">Numeric</span>,
then you could use the NT
Write Value VI from
the <strong>WPI Robotics
Library»Dashboard</strong><span style="font-weight: bold;"> </span>palette
on the robot to write to that indicator. &nbsp;You would simply
use&nbsp;<span style="font-weight: bold;">Numeric</span>
as the <span style="font-weight: bold;">Name</span>
input of the NT Write Number VI. &nbsp;Of course you may want to
change
the name of controls and indicators on the Custom tab to better
represent your robot sensors and actuators.</p>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="intvision">Tutorial
8—Integrating
Vision into Robot
Code</a></h2>











<p class="Body">Use the FRC
Vision examples to better understand how to
use the camera and the Vision software to find and track objects. This
tutorial demonstrates how to explore the 2017 Vision Example
project and incorporate it into your robot code.</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;This
example project assumes
the following:
      
      
      
      
      
      
      
      
      
      
      <ul>











        <li>For the retroreflective portion, you have a ring
light
mounted to the camera.</li>











        <li>For Axis cameras, you have used the
camera setup utility to configure the camera.</li>











        <li>For the RT portion, you have configured the
laptop networking to
a compatible IP address.</li>











      
      
      
      
      
      
      
      
      
      
      </ul>











      </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<h4>Part 1—Open the
Example</h4>











<p class="Body">First you
must open the example you want to use.
Complete the following steps to open the 2017 Vision Example.</p>











<ol>











  <li>On the <strong>Getting
Started</strong> window, go to the <strong>Support</strong>
tab and click <strong>Find FRC
Examples</strong> to display the NI
Example Finder.</li>











  <li>Under the <strong>FRC
Robotics</strong> folder,
double-click the <strong>Vision</strong>
folder to view Vision examples.</li>











  <li>Double-click <strong>2017 Vision
Example.lvproj</strong>
to open the project.</li>











  <li>In the <strong>My
Computer</strong> section of the <strong>Project
Explorer</strong>, double-click <strong>FRC Color
Processing Example.vi</strong> to open the
VI.<br>











    <br>











Notice that there are additional example VIs in the project, including Vision Example Robot Main VI in the <strong>RT
roboRIO Target</strong> section.
You will use that VI to deploy the
code to your roboRIO in part 2, but right now you just want
to run and experiment with the example on the host computer.</li>











  <li>Run the VI by clicking the <strong>Run</strong>
button and use the provided images to explore manual and automatic color calibration, the range of scores, etc.</li>











  <li>Connect the USB or IP camera to your
computer and flip the Source tab to Camera. Check the address used
to communicate with your
camera. USB 0 or USB 1 or axis-camera.local are common addresses.</li>











  <li>You should see the Original Image and possibly other fields
update
when your camera is working properly.</li>











  <li>Aim the camera at a target to verify that the Masked
image identifies
it and displays measurements of it. If necessary, you can adjust the LED Color fields to improve
the mask. You can also auto-calibrate LED Color fields by clicking and drawing a line on a colored section of the image.</li>











  <li>Measure the distance to the
target and compare to the value
reported in the Detected Targets section of the VI. The distance is
computed using camera lens information. You may need to select a
different camera or measure the lens field-of-view and modify the
distance calcuation to use your specific value. In order to achieve a
better distance estimate, you may also want to correct for distortion
caused
by lens and camera mount angle. This can be accomplished by running the
Vision Calibration Training application located at
Start&gt;&gt;National Instruments&gt;&gt;Vision&gt;&gt;Utilities. The
Distortion Model(Grid) should be an appropriate method. It makes use of
a grid of dots printed from C:\Users\Public\Documents\National
Instruments\Vision\Documentation.
You may also need to mount the printed pdf so that it is flat (not
warped) and held vertical, parallel to the cylinder you are measuring
to. Follow the remainder of the wizard directions and store the
calibration file near the example code. The calibration image needs to
match the size of the camera's returned images. You may also want to
update the
code constants in the top left of the diagram to point to the
calibration image.</li>











</ol>











<p>There is an additional example in the My Computer section of the
project that identifies some colored pattern on the lower area of the
scoring tower. Note that the colors are not unique on the field, so it
is key that geometric information
is used to ignore taped lines, bumpers, and other objects using this
color. Also, don't forget that the color will change depending on which
alliance your robot is scoring against.
<br>
<br>
There is also an example that may assist with setting up the camera to
use with a ring light. It reads from the camera and graphs statistical
info about the pixels in the image. If calibrated with the LED color,
it will also display the mask and indicate the saturation level of the
the masked color area.
</p>











<h4>Part 2—Run the VI on
the RT roboRIO Target</h4>











<p class="Body">Complete
the following steps to run the vision example on the roboRIO.</p>











<ol>











  <li>To avoid window clutter, you may want to close the My
Computer VIs that were opened. Do not save any changes that
you made to the VI.</li>











  <li>In the <strong>Project
Explorer</strong>, right-click <strong>RT
roboRIO Target</strong> and
select <strong>Properties</strong>
from
the shortcut menu. Change the IP Address/DNS Name to match your roboRIO
and
click <strong>OK</strong>.</li>











  <li>In the <strong>RT
roboRIO Target</strong> section,
double-click <strong>Vision
Example Robot Main.vi</strong> to
open
the VI.</li>











  <li>Connect the roboRIO and
computer using USB, wifi, or ethernet cable so they are able
to communicate.
Click the <strong>Run</strong>
button to deploy and debug the VI on the RT target.</li>











  <li>From the block diagram of
Vision Example Robot Main,
double-click the Vision Processing VI, and then repeat the steps in
part 1 to experiment with the VI when it runs on the RT target.</li>











  <li>Close all the VIs from the
example Vision project. Do not save
any of the changes you made.</li>











</ol>











<h4>Part 3—Integrate the
Example VI into a Robot Project</h4>











<p class="Body">After you
experiment with the example and see how it
works, you can save a copy of the VI and all the files it depends on to
a new location to use it in your robot project.</p>











<ol>











  <li>Open the Vision Example
Robot Main VI from the <strong>RT
roboRIO Target</strong> section
in the <strong>Project Explorer</strong>,
and open the Vision Processing VI.</li>











  <li>From the Vision Processing VI,
select <strong>File»Save
As</strong>
and select the <strong>Duplicate
hierarchy to new location</strong>
option. Then click <strong>Continue</strong>.</li>











  <li>Navigate to your robot
project directory and click the <strong>Current
Folder</strong> button to save a
copy of the example Vision VI and all
of its dependency files to your robot project.
    
    
    
    
    
    
    
    
    
    
    <table class="Borderless">











      <tbody>











        <tr>











          <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











          <td><strong>Note</strong>&nbsp;&nbsp;
After you click <strong>Current
Folder</strong>, a dialog box
appears warning you that you are
overwriting two VIs in your robot project, the existing Vision
Processing VI and the Robot Globals. This is correct. You do want to
overwrite these two existing VIs with the example VIs you are saving.</td>











        </tr>











      
      
      
      
      
      
      
      
      
      
      </tbody>
    
    
    
    
    
    
    
    
    
    
    </table>











  </li>











  <li>Run your robot project code.</li>











  <li>From the block diagram, open
the Vision Processing VI and verify
that it works as expected.</li>











</ol>











<p>If you are using calibration, you will also want to ensure that your
calibration file is deployed to your controller and loaded
from the correct location. The code in the upper left of Vision.vi
expects the calibration file(s) to be located in the data directory of
your built exe. First, locate the calibration files and drag/drop them
to beneath the roboRIO target of your project. Next, you can edit the
project's Build Specifications, the Source Files section will allow you
to select the calibration files and click the arrows in the Always
Include section to include them with a deployment. You may also want to
ensure that in the Destination section, your Support Directory points
to the natinst/bin/data directory. </p>











<p>
If you would like to incorporate any of the vision processing into the
dashboard, it
is best to base them on the My Computer versions and merge the
processing into
Loop 2, the one that retrieves images from the robot camera. It is also
possible to incorporate calibration in the Dashboard, but processing on
the roboRIO. Dashboard calculated details can be communicated to the robot using the
Network Table VIs as
described in the Dashboard customization tutorial.
</p>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table
of Contents</a></p>











<hr>
<br>











<br>











<h2><a name="CanGettingStarted">Tutorial
9—Getting
Started with
CAN</a></h2>











<h3><span style="font-weight: normal;">A Controller
Area
Network (CAN)
bus is a high-integrity serial bus system for networking intelligent
devices. CAN busses and devices are common components in automotive and
industrial systems. &nbsp;</span></h3>











<h3>CAN Devices</h3>











<p class="Body">The
following devices can communicate over CAN bus.</p>











<ul>











  <li>roboRIO—<span style="font-weight: normal;">sends
messages
to power pneumatic solenoids, control motors, and read voltage and
current status.</span></li>











  <li>Power Distribution Panel
(PDP)—logs channel currents,
battery voltage, and temperature which can be read over CAN bus by the
roboRIO.</li>











  <li>Pneumatic Control Module
(PCM)—receives messages from the
roboRIO to control solenoids. &nbsp;It also has a built in control
loop
that reads the pressure switch and runs the compressor.</li>











  <li>Motor Speed
Controllers—some motor controllers, such as
the Talon SRX, can be controlled over CAN bus.</li>











</ul>











<br>











<h3>Wiring</h3>











Wiring for CAN is typically a 16 to 24 AWG twisted pair of stranded
wire - one green and one yellow. &nbsp;Since the roboRIO and PDP
are
always part of the robot system, they each provide CAN termination
resistors. &nbsp;A termination resistor is built into the roboRIO,
so<span style="font-weight: normal;">
it must be at one end of the CAN bus
chain. &nbsp;The </span><span style="font-weight: normal;">PDP
has a
jumper selectable termination resistor, so it&nbsp;is recommended
to
make
the PDP the other end of the CAN chain. &nbsp;Typical wiring starts
at
the roboRIO, daisy chains to other devices, and&nbsp;ends
at&nbsp;the
PDP. &nbsp;Some devices have two pairs of CAN terminals.
&nbsp;This
is&nbsp;for wiring convenience - wire to that CAN device from a
previous device in the chain, and then from that CAN device to the next
device in the chain. &nbsp;There is no input or output to the CAN
bus.<br>











<br>











While making the PDP one end of the wiring chain is convenient from the
terminating resistor perspective, it may not be convenient from a
wiring perspective. &nbsp;Suppose the roboRIO and PDP are on one
end of
your robot, and several CAN based motor speed controllers are on the
other. &nbsp;In this case you might choose to wire from the roboRIO
to
the PDP, and from the PDP to your motor speed controllers.
&nbsp;This
will work as long as you remove the termination resistor jumper on the
PDP, and add a 100 ohm resistor to the motor speed controller at the
end of the chain.<br>











</span>
<h3>Examples</h3>











<p class="Body">The easiest
way to get started using CAN is by
running&nbsp;examples. &nbsp;You can find CAN examples with the
NI
Example Finder. &nbsp;Launch the Example Finder by clicking the <span style="font-weight: bold;">Find FRC Examples...</span>
link on the
Support tab of the LabVIEW Getting Started window. &nbsp; If you
already have a LabVIEW project or VIs open, you can also launch the
Example Finder from the <span style="font-weight: bold;">Help&gt;&gt;Find
Examples...</span>
menu item.
&nbsp;In the Example Finder you will find
CAN examples for pneumatics. &nbsp;The examples&nbsp;show you how to
wire all the needed hardware. &nbsp;If you have installed third-party
CAN software for a motor controller, it may have included CAN motor
examples.</p>











<br>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table
of Contents</a><br>











</p>











<br>











<hr>
<h2><a name="simulation"></a>Tutorial
10 - Robot Simulation</h2>











With LabVIEW you can use Robot Simulation to program a predefined robot
without having an RT roboRIO Target. This allows multiple developers
to
concurrently create and test LabVIEW code without requiring each
developer to have access to the hardware. Programming is the same,
except only the predefined Actuators and Sensors on the simulated robot
are&nbsp;supported. Robot code that has been developed and works in
simulation mode can be moved to the RT roboRIO Target and run on a
real robot.<br>











<h4>Opening the Robot Simulator</h4>











1. Start the FRC Driver Station. This is required for both
real and simulated robots.<br>











<br>











<img style="width: 1023px; height: 202px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/2016DriverStation.gif" alt=""><br>











<br>











<br>











2. Create a New <span style="font-weight: bold;">FRC
roboRIO
Robot Project</span> either from the
Getting Started Window or by going
to File&gt;&gt;New…<br>











<br>











<br>











<img style="width: 702px; height: 549px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/2015ProjectWizard.gif" alt=""><br>











<br>











<br>











3. Enter your <span style="font-weight: bold;">Team number</span>,
and
choose one of the projects<span style="font-weight: bold;"></span><span style="font-weight: bold;"></span>. &nbsp;<span style="font-size: 8pt; font-family: &quot;Verdana&quot;,sans-serif; color: black;">Entering your team number will automatically determine the IP address for you. For example, if your
Team number is 1959, the IP address of the RT roboRIO Target will roboRIO-1959-FRC<span class="GramE">.local</span>. You may choose any of the roboRIO project options
to access the simulator.</span><br>











<br>











<br>











<img style="width: 603px; height: 439px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/createrobotproj_dialog.gif" alt=""><br>











<br>











<br>











4. When the LabVIEW Project opens, select and open <span style="font-weight: bold;">Robot
Main.vi</span>.<br>











<br>











5. Right-click in the lower left corner of <span style="font-weight: bold;">Robot Main.vi</span>
and choose <span style="font-weight: bold;">2017
Robot
Project.lvproj/My Computer</span>.&nbsp;
Wait a moment
while the subVI’s reload. &nbsp;<span style="font-size: 8pt; font-family: &quot;Verdana&quot;,sans-serif; color: black;">Be aware that the name of the
project will match the name you chose for your project and may be different than
the name shown here.</span><br>











<br>











<br>











<img style="width: 815px; height: 588px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/ContextChange.gif"><br>











<br>











<br>











6. Run<span style="font-weight: bold;">
Robot
Main.vi</span> and the <span style="font-weight: bold;">FRC
Simulation
Viewer</span> opens.<br>











<br>











<br>











<br>











<img style="width: 848px; height: 554px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/RunSimViewer.gif" alt=""><br>











<br>











<br>











7. The <span style="font-weight: bold;">FRC
Driver
Station</span> should now show that
you
have a <span style="font-weight: bold;">Simulated
Robot</span>. Click <span style="font-weight: bold;">Enable</span>
to place
the robot in <span style="font-weight: bold;">Teleoperated
Enabled </span>mode.<br>











<br>











<br>











<br>











<img style="width: 1026px; height: 202px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/DriverStationSimulated.gif" alt=""><br>











<br>











<br>











8. You
should now be able to use a joystick to drive the robot in the <span style="font-weight: bold;">FRC Simulation Viewer</span>.<br>











<br>











9. The <span style="font-weight: bold;">Camera
Image</span>
and <span style="font-weight: bold;">Drive&nbsp;Motors</span>
can be monitored in the <span style="font-weight: bold;">FRC
PC Dashboard</span>.&nbsp; Choose&nbsp;<span style="font-weight: bold;">Camera</span> from the drop-down menu tab&nbsp;<span style="font-weight: bold;"></span><span style="font-weight: bold;"></span>to
view the robot camera<span style="font-weight: bold;"></span>.&nbsp;
Changing
to a
lower frame rate will help performance on slower computers.<br>











<br>











<br>











<img style="width: 1044px; height: 442px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/Dashboard.gif" alt=""><br>











<br>











<br>











<br>











<h4>Using the Simulator Viewer</h4>











<img style="width: 888px; height: 602px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/SimViewer.gif" alt=""><br>











<br>











<br>











<br>











<p class="MsoNormal" style="line-height: normal;">Aside
from Teleoperation
of the simulated robot
using the
joystick, there are several options in the FRC
Simulator Viewer to help
customize your simulation environment:</p>











<ul>











  <li><span style="font-weight: bold;">Simulate</span>—<span style="font-weight: bold;">Run</span>
and <span style="font-weight: bold;">Pause</span>
buttons
are available.</li>











  <li><span style="font-weight: bold;">Time
Factor</span>—allows
you to run
the dynamic model of the system slower than real time (minimum 0.25)
and faster
than real time (maximum 20.0).&nbsp; A Time
Factor of 1.0 will be representative of the system in real time.</li>











  <li><span style="font-weight: bold;">View—Side</span>
or <span style="font-weight: bold;">Driver</span>
enables
you to default back to one of the two traditional points of
view.&nbsp;
If <span style="font-weight: bold;">Follow</span>
is <span style="font-weight: bold;">Off</span>,
left-clicking and panning in the Viewer window will allow you
to choose a custom viewing angle.</li>











  <li><span style="font-weight: bold;">Follow</span>—If
you turn Follow <span style="font-weight: bold;">On</span>,
the Viewer will keep the robot
centered in the screen from whichever <span style="font-weight: bold;">View</span>
you have selected.&nbsp; If you turn Follow <span style="font-weight: bold;">Off</span>,
left-clicking and
panning in the Viewer window will allow you
to choose a custom viewing angle, but zooming is no longer possible.</li>











  <li><span style="font-weight: bold;">Color</span>—selects
the
background color.</li>











  <li><span style="font-weight: bold;">Driver
Station IP—Auto</span>
should be set to connect with the correct IP Address
based on
the RT roboRIO
Target properties in the
LabVIEW
Project Explorer, but there is also an option to <span style="font-weight: bold;">Set</span>
the
IP address manually.</li>











  <li><span style="font-weight: bold;">Close</span>—Close
the FRC
Simulation Viewer and stop Robot Main.vi.</li>











</ul>











<br>











<h4>Programming a simulated robot</h4>











The
simulated robots are predefined - they cannot be changed. &nbsp;But
they are the same as real robots in that they have sensors and
actuators attached. &nbsp;By default each project includes code
to drive the robot. &nbsp;Beyond that, it is up to you to
add&nbsp;code
to make use of additional sensors and actuators included on each
robot. &nbsp;For example, each simulated robot includes a gyro.
&nbsp;By following <span style="font-weight: bold;">Tutorial
7 -
Integrating
Examples into Robot Code</span>, you
can learn how to add Gyro code for your simulated robot. &nbsp;Once
you get that working in simulated mode, the same code can be built for
a real robot. <br>











<br>











In order to program each simulated robot, you need to know which
sensors and actuators it has. &nbsp;You also need to know how each
is
wired - which&nbsp;channel each uses.<br>











<br>



<br>











The simulated sensors and actuators are dependent on which project you
choose. &nbsp;Below is a list for each project. &nbsp;You can
also find
this list within each project in <span style="font-weight: bold;">Robot
Simulation Readme.html</span>&nbsp;under
<span style="font-weight: bold;">My
Computer</span>.<br>











<h4>Supported
Actuators and Sensors on the Simulated Robots</h4>











<h5>1.<span style="font-weight: bold;"> Arcade Drive</span></h5>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Actuators on the simulated
robot</h6>











<ol>











  <li>Left Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 0 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Right Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 1 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Camera Servo
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 5 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











</ol>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Sensors on the simulated robot</h6>











<ol>











  <li>Encoder on Right Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>A Channel = DIO 3 </li>











      <li>B Channel = DIO 4 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Encoder on Left Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>A Channel = DIO 5 </li>











      <li>B Channel = DIO 6 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Gyro <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Analog Channel = AI 1 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>SRF04 Ultrasonic <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Ping DIO Channel = DIO 1 </li>











      <li>Echo DIO Channel = DIO 2 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>AXIS M1011 Camera</li>











</ol>











<br>











<h5><br>



</h5>



<h5>2. Arcade Drive with Arm</h5>











<br>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Actuators on the simulated
robot</h6>











<ol>



  <li>Left&nbsp;Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>PWM Channel = PWM 0 </li>



    
    
    
    </ul>











  </li>



  <li>Right&nbsp;Motor</li>



  
  
  
  <ul>



    <li>PWM Channel = PWM 1</li>



  
  
  
  </ul>



  <li>Camera Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>PWM Channel = PWM 5 </li>



      <li>Angular Range = 170 </li>



    
    
    
    </ul>











  </li>



  <li>Arm Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>PWM Channel = PWM 6 </li>



      <li>Angular Range = 170 </li>



    
    
    
    </ul>











  </li>



  <li>Gripper Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>PWM Channel = PWM 7 </li>



      <li>Angular Range = 170 </li>



    
    
    
    </ul>











  </li>



</ol>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Sensors on the simulated robot</h6>











<ol>



  <li>Encoder on Right Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>A Channel = DIO 3 </li>



      <li>B Channel = DIO 4 </li>



    
    
    
    </ul>











  </li>



  <li>Encoder on Left Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>A Channel = DIO 5 </li>



      <li>B Channel = DIO 6 </li>



    
    
    
    </ul>











  </li>



  <li>Gyro <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>Analog Channel = AI 1 </li>



    
    
    
    </ul>











  </li>



  <li>Ultrasonic <br>











    
    
    
    
    
    
    
    
    
    
    <ul>



      <li>Ping DIO Channel = DIO 1 </li>



      <li>Echo DIO Channel = DIO 2 </li>



    
    
    
    </ul>











  </li>



  <li>AXIS M1011 Camera </li>



</ol>



<h5></h5>



<h5><br>



</h5>



<h5>3. Mecanum Drive with Arm</h5>











<br>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Actuators on the simulated
robot</h6>











<ol>











  <li>Left Front Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 0 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Right Front Motor</li>











  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>PWM Channel = PWM 1</li>











  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Left Rear Motor</li>











  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>PWM Channel = PWM 2</li>











  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Right Rear Motor</li>











  
  
  
  
  
  
  
  
  
  
  <ul>











    <li>PWM Channel = PWM 3</li>











  
  
  
  
  
  
  
  
  
  
  </ul>











  <li>Camera Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 5 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Arm Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 6 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Gripper Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 7 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











</ol>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Sensors on the simulated robot</h6>











<ol>











  <li>Encoder on Right Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>A Channel = DIO 3 </li>











      <li>B Channel = DIO 4 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Encoder on Left Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>A Channel = DIO 5 </li>











      <li>B Channel = DIO 6 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Gyro <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Analog Channel = AI 1 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Ultrasonic <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Ping DIO Channel = DIO 1 </li>











      <li>Echo DIO Channel = DIO 2 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>AXIS M1011 Camera </li>











</ol>











<br>











<h5><br>



</h5>



<h5>4.&nbsp;<span style="font-weight: bold;">Arcade
Command &amp; Control</span></h5>











<br>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Actuators on the simulated
robot</h6>











<ol>











  <li>Left&nbsp;Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 0 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Right&nbsp;Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 1 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Camera Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 5 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Arm Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 6 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Gripper Servo <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>PWM Channel = PWM 7 </li>











      <li>Angular Range = 170 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











</ol>











<h6>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; Sensors on the simulated robot</h6>











<ol>











  <li>Encoder on Right Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>A Channel = DIO 3 </li>











      <li>B Channel = DIO 4 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Encoder on Left Motor <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>A Channel = DIO 5 </li>











      <li>B Channel = DIO 6 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Gyro <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Analog Channel = AI 1 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>Ultrasonic <br>











    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Ping DIO Channel = DIO 1 </li>











      <li>Echo DIO Channel = DIO 2 </li>











    
    
    
    
    
    
    
    
    
    
    </ul>











  </li>











  <li>AXIS M1011 Camera </li>











</ol>











<br>











<h4>Notes:</h4>











<ol>











  <li> If you run a robot in
simulation mode, but you have programmed
it for I/O not supported in simulation mode, then errors will be
generated that slow the simulation performance. You can check for
errors in the Messages box of the FRC Driver Station.</li>











  <li>The
E-Stop (space
bar) works in Simulation Mode.&nbsp;
To reset
it, simply wait 5 seconds and then stop and rerun <span style="font-weight: bold;">Robot
Main.vi</span>.</li>











  <li>To
change the <span style="font-weight: bold;">Robot
Main.vi</span> to be able to run on
the
target again, you will need to right
click
in the lower left corner of <span style="font-weight: bold;">Robot
Main.vi</span> and choose <span style="font-weight: bold;">2016
Robot Project.lvproj/Target</span>.&nbsp;
Wait a moment while the subVI’s
reload.</li>











</ol>











<img style="width: 473px; height: 585px;" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/ContextSwitchBack.gif" alt=""><br>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table
of Contents</a></p>











<hr>
<h2><br>











</h2>











<h2><a name="command"></a>Tutorial
11 - Command and Control Project</h2>











When you create a new FRC robot project, one of the&nbsp;template
choices is <span style="font-weight: bold;">Arcade
Drive - Command &amp; Control</span>. Command and control
is an architecture that is an extension of the existing iterative
framework, where commands&nbsp;are scheduled and sent from within
the Main loop down to subsystems that run independently. VIs like
Teleop and Autonomous still exist, but they generally send commands instead
of directly controlling outputs such as motors. &nbsp;There are
several advantages to command and control:<br>











<ul>











  <li>Multiple subsystems&nbsp;run simultaneously and
independently, so they do not block each other.</li>







  <li>Subsystems can be self-contained, so it is easy to disable them for debugging.</li>







  <li>It is easier to divide&nbsp;programming tasks during development.</li>







  <li>Changes to subsytem implementation, even swapping gearboxes
or changing sensor types, will have less impact on code that issues
commands.</li>







  <li>One subsystem can be programmed to handle many different types
of commands.</li>







  <li>Being an extension of the existing architecture, subsystems
can be added as needed, but are not required for all I/O.</li>












</ul>











<br>











<br>











<h3>Understanding the default Subsystem in the project</h3>











<br>











In the <span style="font-weight: bold;">Project Explorer</span>,
notice the command and control project comes with a Subsystem named <span style="font-weight: bold;">Drive</span> which is used
to drive two motors.<br>











<br>











<img style="width: 498px; height: 677px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlProject.gif"><br>











<br>











Within <span style="font-weight: bold;">Drive</span>
is a&nbsp;<span style="font-weight: bold;">Commands</span>
folder and an <span style="font-weight: bold;">Implementation</span>
folder.<br>











<span style="font-weight: bold;"><br>











</span>
<ul>











  <li><span style="font-weight: bold;">Commands</span>
are used to schedule a task.</li>











  
  
  
  
  
  
  
  
  
  
  <ol>







    <li><span style="font-weight: bold;">Drive for
Time.vi</span> can be used in Autonomous to create a drive sequence.<span style="font-weight: bold;"></span></li>








    <li><span style="font-weight: bold;">Drive
Immediate.vi</span> works well for Teleop &nbsp;joystick
motor control.</li>








    <li>Templates make it easy to create additional commands.</li>







  
  
  
  
  
  
  </ol>











  <li><span style="font-weight: bold;">Implementation</span>
includes a controller VI, along with typedefs used by the controller.</li>











  
  
  
  
  
  
  
  
  
  
  <ol>







    <li><span style="font-weight: bold;">Drive
Operations.ctl</span> is a type definition (typdef) Enum control
that lists all the operational modes of a subsystem.</li>







    <li><span style="font-weight: bold;">Drive
Setpoints.ctl</span> is a typedef cluster control that includes
the <span style="font-weight: bold;">Drive Operations.ctl</span>
as well as all set point values that commands will pass to the controller.</li>







    <li><span style="font-weight: bold;">Drive
Controller.vi</span>
processes all the commands. &nbsp;When you
create a new subsystem, this is where you would do most of your
programming. &nbsp;The&nbsp;controller&nbsp;runs
independently of the code that scheduled the command and often operates
as a control loop or a state machine. The panel of this VI can also
display charts or other diagnostic
information showing details of subsystem operation.</li>







  
  
  
  
  
  
  </ol>











</ul>











<br>











Let's see how these VIs are used in the project - starting with <span style="font-weight: bold;">Robot
Main.vi</span>.<br>











<img style="width: 651px; height: 630px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlMain.gif"><br>











<br>











Notice that&nbsp;Periodic Tasks.vi has been replaced with <span style="font-weight: bold;">SubSystems.vi</span>. In
the command and control framework this is where all the controllers
reside. Within <span style="font-weight: bold;">SubSystems.vi</span>
we see <span style="font-weight: bold;">Drive
Controller.vi</span>. &nbsp;When you create a new Subsystem,
its controller VI will&nbsp;be added to SubSystems.vi for you.<br>











<br>











<br>











<img style="width: 305px; height: 349px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlSubSystems.gif"><br>











<br>











The block diagram of <span style="font-weight: bold;">Drive
Controller.vi</span> is where the most important programming of
your subsystem takes place. The block diagram contains comments explaining how
to edit code to add sensors and actuators and implement new operational modes.
&nbsp;The basic idea is to open I/O to the left of the while loop and wire
the refnums into the loop. &nbsp;The while loop, and the code within it, implement the control loop and/or state machine
that defines the subsystem behavior. &nbsp;Each case also produces two outputs, <span style="font-weight: bold;">Finished?</span> and <span style="font-weight: bold;">Wait Time</span>, that are&nbsp;used to control the loop timing and the next operational mode.<br>











<br>











<img style="width: 1250px; height: 521px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlDriveDiagram.gif"><br>











<br>











Let's look at each Controller programming step on the diagram:<br>











<ul>











  <li><span style="font-weight: bold;">Step1</span>:
Initialize things like motors and sensors. If you are familiar with the
existing LabVIEW robot architectures, you will recognize this as code
that used to be in <span style="font-weight: bold;">Begin.vi</span>.
In fact you could still put this code in <span style="font-weight: bold;">Begin.vi</span>, but the
advantage of having it here is that it puts all your controller code in
one place. It is also possible to avoid publishing the refnums or publish them only for Test Mode.
This ensures that I/O can only be updated from the controller and avoids race conditions in parallel code.
&nbsp;And, if you want to disable one of your subsystems - all
you have to do is comment out the controller VI.</li>









  <li><span style="font-weight: bold;">Step 2</span>:
Define the default operation and setpoints. Notice here that <span style="font-weight: bold;">Reserve</span> is the
default operation. There is always a <span style="font-weight: bold;">Reserve</span> command when
you create a subsystem - it is used to set the controller to a known
state when no commands are being handled. The setpoints included for
the Drive subsystem are <span style="font-weight: bold;">Left
Setpoint</span>, <span style="font-weight: bold;">Right
Setpoint</span>, and <span style="font-weight: bold;">Duration</span>.
&nbsp;These are values that will be passed by the <span style="font-weight: bold;">Drive for Time.vi </span>or&nbsp;<span style="font-weight: bold;">Drive Immediate.vi</span>
command VIs. &nbsp;If you&nbsp;needed to
add&nbsp;operations or setpoints, you could right-click on the <span style="font-weight: bold;">Default Command</span>
constant and choose <span style="font-weight: bold;">Open
Type Def</span> to edit these items.</li>











  <li><span style="font-weight: bold;">Step 3</span>:
Add cases and code to handle each operation. &nbsp;When you create
a subsystem, this is where you will add most of your own code to read
sensors, perform calculations, and update actuators. &nbsp;In the
picture above, the <span style="font-weight: bold;">Drive
for Time</span> operation is being handled. &nbsp;Notice how
the <span style="font-weight: bold;">Duration</span> is being checked to determine&nbsp;whether to keep
driving or if the command is finished. &nbsp;This leads us to the <span style="font-weight: bold;">Drive Cmd Check</span> VI
to the lower right outside the case structure which has three inputs:
    
    
    
    
    
    
    
    
    
    
    <ul>











      <li>Finished? - tells it whether or not the current command
is finished.</li>











      <li>Wait Time (ms) - defines how long the current
case will be delayed before another iteration. The arrival of a new
command cancels this wait.</li>











      <li>input cluster (current command) - tells it the current
command Operation being handled.</li>











    
    
    
    
    
    
    
    
    
    
    </ul>










If <span style="font-weight: bold;">Finished?</span> is true, <span style="font-weight: bold;">Drive Cmd Check</span> will return the default Operation, which in this case is Reserve. &nbsp;If <span style="font-weight: bold;">Finished?</span> is false, it will wait for a new command or until the time specified by <span style="font-weight: bold;">Wait Time</span> has
passed. &nbsp;If a new command is received, the current one is aborted
and the new one begins immediately. &nbsp;If no new command is
received, the
current command code runs over and over until it completes or is
interrupted by
another command.</li>











  <li><span style="font-weight: bold;">Step 4</span>:
Format text to describe the current command. This 
string&nbsp;is passed to the
    <span style="font-weight: bold;">Trace</span>
VI. &nbsp;The <span style="font-weight: bold;">Trace</span>
VI creates a buffer of recent commands of all subsystems. Open the
Trace panel and press the Enable while your code is running - this is
useful for seeing how subsystems are being commanded and how they
complete.</li>










  <li><span style="font-weight: bold;">Step 5</span>: Update your I/O.
&nbsp;If your I/O is common to all of your Operation cases, it makes
sense to call it outside of and after the case structure. &nbsp;In this
example, the <span style="font-weight: bold;">RobotDrive Motors</span>
VI is being called. &nbsp;While common, calling I/O outside the case
structure is not required. &nbsp;For example if you are controlling a
servo, it is not required to be constantly updated. &nbsp;You may want
to update your servo only within the cases where an update is wanted.</li>











</ul>










Now that we have an overview of the controller code, let's take a look at the&nbsp;Operation case for each command. The <span style="font-style: italic;">Immediate</span> case is very basic:<br>










<br>










<img style="width: 681px; height: 335px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControl_Immediate.gif"><br>










It passes the left and right setpoint speeds from the command cluster
to the RobotDrive VI. &nbsp;The input cluster in the lower left corner
contains a U32 for the <span style="font-weight: bold;">Start Time</span> of the command and an I32 for the <span style="font-weight: bold;">Iterations</span>
count. &nbsp;Recall that the two output wires at the lower right
indicate if the command has finished and the wait time for another
command. &nbsp;In this case we are finished if 50 ms has passed since
this command started. &nbsp;This means this command will loop over and
over for 50 ms if it isn't interrupted by another command. &nbsp;Once
finished, <span style="font-weight: bold;">Drive Cmd Check</span> will return the default command which is <span style="font-style: italic;">Reserve</span>:<br>










<br>










<img style="width: 681px; height: 335px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlReserve.gif"><br>










<br>










The Reserve case stops the motors by sending 0 for the left and right speed. &nbsp;It also passes -1 to <span style="font-weight: bold;">Drive Cmd Check</span>
which tells it to wait indefinitely for a new command. &nbsp;In this
state the controller sleeps and uses no resources until a new command
is sent.<br>










<br>










The final Operation case for this controller is <span style="font-style: italic;">Drive for Time</span>:<br>










<br>










<img style="width: 681px; height: 335px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlDriveForTime.gif"><br>










<br>










Here the Duration is used to determine when this command is finished.
&nbsp;The elapsed time is subtracted from the Duration and passed to
the <span style="font-weight: bold;">Max &amp; Min</span> function. &nbsp;The&nbsp;<span style="font-weight: bold;">Max &amp; Min</span>
function&nbsp;makes sure that the longest timeout passed is 50 ms.
&nbsp;This ensures&nbsp;the motors are updated often enough that the
Drive Safety feature doesn't turn them off. &nbsp;Once the elapsed time
exceeds the Duration, the <span style="font-weight: bold;">Finished?</span> value will be true, and the controller will go back to the Reserve case.<br>










<br>










Now that we understand how commands are handled by the controller, let's look at how commands are sent to the controller.<br>










<br>










<h3>Using Commands</h3>










If we look at the Teleop VI code, we can see that the <span style="font-weight: bold;">Immediate</span> and <span style="font-weight: bold;">Drive for Time</span> commands are being used.<br>










<br>










<img style="width: 576px; height: 452px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlTeleop.gif"><br>










<br>










The joystick X and Y axes are being passed to the <span style="font-weight: bold;">Drive Immediate</span>
VI. &nbsp;This drives the robot as we would expect with a joystick.
&nbsp;But instead of sending X and Y values to RobotDrive VIs,
we&nbsp;send commands to the Drive controller and let it control the
motors. &nbsp;Pressing joystick buttons 1 or 2 will call the <span style="font-weight: bold;">Drive for Time</span>
command VI shown the the case structures. &nbsp;Here, constant values
for Left Speed, Right Speed, and Duration are used to turn the robot
right or left for a given amount of time. &nbsp;You can edit these
values to experiment and better understand how they work.<br>










<br>










It's&nbsp;important to remember that Teleop gets called every 20 ms, so let's think about what this code would do. &nbsp;<span style="font-weight: bold;">Drive Immediate</span>
gets called every time Teleop runs, so it will be getting called over
and over passing the X and Y joystick values. &nbsp;Meanwhile, if a
button is pressed <span style="font-weight: bold;">Drive for Time</span> will be called and can interrupt the immediate command. &nbsp;But then wouldn't <span style="font-weight: bold;">Drive Immediate</span> get called again and interrupt <span style="font-weight: bold;">Drive for Time</span>? &nbsp;Let's take a look at the code within these command VIs to better understand what would happen.<br>










<br>










<span style="font-weight: bold;">Drive Immediate VI</span>:<br>










<br>










<img style="width: 777px; height: 339px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlDriveImmediate.gif"><br>










<br>










<span style="font-weight: bold;">Drive Command Helper</span> VI, provided by the infrastructure,
sends the command to the controller. &nbsp;Notice that it is in a case structure and gets
called only when a left or right setpoint exceeds the deadband value. &nbsp;This
is what keeps <span style="font-weight: bold;">Drive Immediate</span> from interrupting <span style="font-weight: bold;">Drive for Time</span> when the joystick is idle. The <span style="font-weight: bold;">Description</span> input is optional and is very useful when reviewing command Traces. &nbsp;<span style="font-weight: bold;">Command Info In</span> and <span style="font-weight: bold;">Command Info Out</span>
are also optional - they are useful for chaining commands to run one
after another.<br>










<br>










<span style="font-weight: bold;">Drive for Time VI</span>:<br>










<br>










<img style="width: 583px; height: 272px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlDriveForTimeDiagram.gif"><br>










<br>










Here we have two additional VIs provided by the framework. &nbsp;These VIs&nbsp;use the <span style="font-weight: bold;">Synchronization</span>
input, so this VI can Wait -- returning when the command completes, or
it can Start the operation and return immediately. Wait synchronization
will be most useful in autonomous, with Start being used during TeleOp.
The default <span style="font-weight: bold;">Synchronization</span> value is <span style="font-style: italic;">Start</span>.<br>










<br>





The Teleop VI uses command VIs independently. &nbsp;Look at the
Autonomous VI for an example of chaining the commands to build more
interesting robot behaviors.<br>





<br>







Command VIs aren't complicated, but you do not need to write them from scratch. &nbsp;You will typically
create commands by starting from one of the template VIs in the
Commands folder of the project. The following section shows how to create a new subsystem and new commands.


<br>





<br>





<br>










<h3>Adding a new Subsystem to the project</h3>










<br>










Now that we have an understanding of the existing Drive subsystem,
let's learn how to add a new subsystem. &nbsp;In this case, since the
included simulated robot has an arm controlled by a servo, we will add
an Arm subsystem. Do this in the project by right-clicking on the
roboRIO Target and choosing <span style="font-style: italic;">New&gt;&gt;Subsystem</span>:<br>










<br>










<img style="width: 495px; height: 674px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlNewSubsystem.gif"><br>










<br>










A <span style="font-weight: bold;">Define Subsystem</span> dialog
opens. Here we have entered Arm for the Subsystem Name, and yellow for
the Icon Color. &nbsp;Operations will be passed by command VIs we
create. &nbsp;We have decided we want three operations: <span style="font-weight: bold;">Immediate</span>, <span style="font-weight: bold;">45 Degrees</span>, and <span style="font-weight: bold;">Throw</span>. &nbsp;Every new subsystem will be created with default operations&nbsp;<span style="font-weight: bold;">Reserve</span>, <span style="font-weight: bold;">Read Current</span>, and <span style="font-weight: bold;">Immediate</span>. &nbsp;That means we only need to add <span style="font-weight: bold;">45 Degrees</span> and <span style="font-weight: bold;">Throw</span>.
&nbsp;You may add as many different operations as&nbsp;needed.
Operations can also be added after subsystem creation by modifying the
control directly.<br>










<br>










<img style="width: 371px; height: 395px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlDefineArmSubSystem.gif"><br>










<br>










Clicking OK creates an Arm subsystem in the project, and opens the Arm
Controller VI. &nbsp;Notice that the Arm subsystem in the project has a
Commands folder and Implementation folder similar to the folders in the
Drive subsystem. &nbsp;The difference is it is up to us to create the
command VIs. &nbsp;The Arm Controller VI that opens is similar to the
Drive Controller VI, except we need&nbsp;to add code according to the
Steps&nbsp;discussed earlier for the Drive Controller VI.<br>










<br>










<h3>Adding Servo code to the Arm Controller VI</h3>










<br>










From the <span style="font-weight: bold;">Robot Simulation Readme.html</span>
file located in the My Computer section of the project, we see that the
simulated Arm Servo is connected to PWM 6 and has an Angular Range of
170 degrees. &nbsp;We will use this information in Step 1 as seen below
configuring the servo. &nbsp;For Step 2 we have edited Arm
Setpoints.ctl. &nbsp;You edit this control by either right-clicking the
edge of the constant shown and choosing <span style="font-weight: bold;">Open Type Def.</span>
or by opening it from the Implementation folder of the Arm Subsystem in
the project. &nbsp;In this control, for this example, we renamed <span style="font-weight: bold;">Setpoint</span> to <span style="font-weight: bold;">Angle</span> and we renamed <span style="font-weight: bold;">Duration</span> to <span style="font-weight: bold;">Degrees per second</span>.
&nbsp;You could also add more controls as needed. &nbsp;While this
control is open, click on the Operations menu - you should see the
three default and two additional operations for a total of five:
Reserve, Read Current, Immediate, 45 Degrees, and Throw. &nbsp;Saving
this control after editing will update the constant on the diagram of
Arm Controller.vi.<br>










<br>










<img style="width: 428px; height: 591px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmSteps1and2.gif"><br>










<br>










Steps 3 and 5, operation code and I/O updates, are combined into each
case structure. &nbsp;Since servos do not require continuous updates,
we can update them within each operation case only as needed.
&nbsp;Let's look at what the code might look like for each operation.<br>










<br>










For <span style="font-weight: bold;">Immediate</span> we simply set the angle each time.<br>










<img style="width: 681px; height: 354px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmImmediate.gif"><br>










<br>










For <span style="font-weight: bold;">45 Degrees</span> we set the angle
to 45 degrees. &nbsp;While this code is very simple, you could expand
on it. &nbsp;For example you could read the current angle, and then use
the <span style="font-weight: bold;">Degrees per second</span> setpoint to move to 45 degrees at a predetermined speed.<br>










<br>










<img style="width: 681px; height: 354px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArm45Degrees.gif"><br>










<br>










For the <span style="font-weight: bold;">Throw</span> case, which might
be used to throw a ball or other object, we immediately move to the
throw angle, and then return to an angle of zero after two seconds.<br>










<br>










<img style="width: 681px; height: 354px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmThrow.gif"><br>










<br>










The code for the <span style="font-weight: bold;">Reserve</span> case does not need to be edited, since the servo will not be moved in this default case.<br>










<br>










With the Arm Controller code written, let's look at creating command VIs to use the operations. &nbsp;Within the <span style="font-style: italic;">Arm&gt;&gt;Commands</span> folder, right-click on <span style="font-weight: bold;">Template for Arm Immediate with Deadband.vit</span> and choose <span style="font-weight: bold;">New from Template</span>.<br>










<br>










<img style="width: 495px; height: 674px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmCreateImmediate.gif"><br>










<br>










From the template we have edited the code to have an Angle input and
Deadband Delta to compare to. &nbsp;This differs from the Drive case
where the deadband was near zero. &nbsp;Here we are looking for enough
of an angle change rather than a near zero value. &nbsp;After editing
we saved this VI as <span style="font-weight: bold;">Arm Immediate with Deadband Delta.vi</span>. This command will be used with the throttle control (Z axis) of a joystick.<br>










<br>










<img style="width: 745px; height: 355px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmImmediateCommand.gif"><br>










<br>










For the Arm 45 Degrees command we similarly create a command from the <span style="font-weight: bold;">Template for Arm Immediate.vit</span>, edit it as shown below, and save it as <span style="font-weight: bold;">Arm 45 Degrees.vi</span>. &nbsp;Notice that all this code does is call the 45 Degrees operation. &nbsp;This command will be used with a joystick button.<br>










<br>










<img style="width: 518px; height: 261px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArm45DegreesCommand.gif"><br>










<br>










For the Arm Throw command we again create a command from the <span style="font-weight: bold;">Template for Arm Immediate.vit</span>, edit it as shown below, and save it as <span style="font-weight: bold;">Arm Throw.vi</span>. &nbsp;Notice this command lets us choose the throw angle. &nbsp;This command will be used with a joystick button.<br>










<br>










<img style="width: 518px; height: 261px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmThrowCommand.gif"><br>










<br>










With three command VIs written, let's look at how we might use
them in the Teleop VI. &nbsp;First notice how easy the command VIs
are to locate, since we chose yellow for the icon color when we created
our subsystem, and the wizard automatically added the word <span style="font-weight: bold;">Arm</span> to the icon. &nbsp;The joystick Z (throttle) axis is being passed to the <span style="font-weight: bold;">Arm Immediate with Deadband Delta </span>VI.
&nbsp;Notice that we have to convert the -1 to 1 output of the joystick
for the 0 to 170 degree angle range of the servo. &nbsp;Pressing
joystick button 3 will run the arm throw motion. &nbsp;Pressing button
4 will set the arm to 45 degrees.<span style="font-weight: bold;"></span><br>










<br>










<img style="width: 646px; height: 718px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/CommandControlArmInTeleop.gif"><br>










Our new subsystem is now complete and integrated into the Teleop code.
&nbsp;But what if we wanted to add another operation after we have
already created our subsystem? &nbsp;To add another operation you
simply open <span style="font-weight: bold;">Arm Operations.ctl </span>from
the Implementation folder and add an additional item to the Enum by
right-clicking on it and choosing Properties. &nbsp;In the Properties
dialog the Edit Items tab allows you to add more operation names.<br>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr style="width: 100%; height: 2px;"><br>











<h2><a name="troubleshoot">Troubleshooting
the Robot</a></h2>











<p class="Body">In the
previous sections, you learned how to program a
robot using the roboRIO, the NI Robotics roboRIO projects,
and the WPI Robotics Library VIs. However, at times, the robot might
not work as you expect. This tutorial provides information about
troubleshooting issues that you might encounter when working with the
robot and solutions to address those issues.</p>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#tooltrouble">Troubleshooting
Common Issues</a><br>











<a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#generaltrouble">Troubleshooting
General Issues</a>
<h3><a name="tooltrouble">TroubleShooting Common
Issues</a></h3>











<p class="Body">This
section introduces you to tools you can use to
diagnose and correct common issues.</p>











<h4>Driver Station Messages</h4>











<p class="Body">Before you
try anything else, view the <strong>Messages</strong>
box on the Driver Station. If your code returns
errors to the Driver Station, those errors cause your code, and
therefore your robot, to run less efficiently.</p>











<h4>Driver Station Diagnostics</h4>











<p class="Body">Hover the
cursor over items on the Diagnostics page to
view information about possible problems with the robot system and
suggestions on how to correct the problems. Edit your robot system or
robot code to correct the errors.</p>











<h4>Driver Station Charts Page</h4>











<p class="Body">Use the
<span style="font-weight: bold;">Charts</span> box to learn how your robot uses system
resources. This tool can help
you determine why your code might run slowly and how to improve the
performance of your robot code.</p>











<h4>Profile Performance and Memory
Tool</h4>











<p class="Body">Use the
Profile Performance and Memory tool to see
timing statistics and memory usage for your code. Navigate to <strong>Tools»Profile»Performance
and Memory</strong> to open this
tool.</p>











<h4>Elapsed Times VI</h4>











<p class="Body">The Elapsed
Times VI, <img style="width: 33px; height: 33px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/ElapsedTimesVI.gif">, is a component of
the robot project
that you create from the <strong>FRC
cRIO Robot Project</strong>
wizard. The VI is located in the <strong>Support
Code</strong> folder,
shown as follows.</p>











<br>











<img style="width: 374px; height: 275px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/ElapsedTimesInProject.gif"><br>











<p class="Body">You can use
this VI throughout your robot code as a
tool to show you how
long a loop or a VI takes to run. Drop the Elapsed Times VI
into a loop in your robot code or onto the block diagram of a robot
code
VI. Then, run your robot code, and open the Elapsed Times VI
to see a list of all the locations in which you placed the VI, as well
as the amount of time each part of the code takes to run. The Elapsed
Times VI includes a <strong>Call
Name</strong> input you can use to
identify where you put the VI in your
code. If you do not wire a value to this input, the Elapsed Times VI
uses the name of the VI
in which you placed it.</p>











<p class="Body">You can
test sections of robot code to make sure
the code does not use more CPU time than you expect. For example, you
can test
the 100 ms loop within the Periodic Tasks VI. Complete the
following steps to check whether the loop iterates at the correct speed.</p>











<ol>











  <li>Open the Periodic Tasks VI,
accessible from the <strong>Team
Code</strong>
folder of the robot project.</li>











  <li>Press the
&lt;Ctrl–E&gt; keys to view the block diagram.</li>











  <li>From the <strong>Support
Code</strong> folder of the robot
project, drag the Elapsed Times VI to the 100 ms loop of the
Periodic Tasks VI.</li>











  <li>Right-click the <strong>Call
Name</strong> input of Elapsed
Times VI, and select Create»Constant from the shortcut menu.</li>











  <li>Enter&nbsp;<span class="Monospace">100 ms
loop</span>
in the
string constant to specify the name that appears when you open the
Elapsed Times VI while the robot code is running.</li>











</ol>











<p class="Body">Your robot
code should appear similar to the following
figure. &nbsp;It might seem obvious that the Elapsed Times VI will
show
this loop running at 100 ms. &nbsp;What is important to understand
is
that you could add so much code to this loop that it would take longer
than 100 ms to run. &nbsp;In that case the Elapsed Times VI would
tell
you how long the loop was actually taking to run.</p>











<br>











<br>











<img style="width: 384px; height: 257px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/100msLoop.gif"><br>











<br>











<p class="Body">You also
can test to see how long the Teleop code takes
to run. Complete the following steps to run this test.</p>











<ol>











  <li>Open the Teleop VI,
accessible from the <strong>Team
Code</strong>
folder of the robot project.</li>











  <li>Press the
&lt;Ctrl–E&gt; keys to view the block diagram.</li>











  <li>From the <strong>Support
Code</strong> folder of the robot
project, drag the Elapsed Times VI to the block diagram of the Teleop
VI.</li>











</ol>











<p class="Body">The block
diagram should appear similar to the
following figure.</p>











<br>











<img style="width: 416px; height: 293px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/TeleopSnippet.gif"><br>











<br>











<p class="Body">Notice that
you did not wire a value to the <strong>Call
Name</strong> input in the previous
steps. In this case the Elapsed
Times VI automatically uses its caller VI, Teleop, for the call name.
While your robot code is running, open the Elapsed Times VI. View the
front panel to see a real-time view of how long each section of code
takes to run. This information can help you find sections of code that
may use more CPU time than you expect.</p>











<br>











<br>











<img style="width: 421px; height: 333px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/ElapsedTimesFrontPanel.gif"><br>











<br>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/note.gif" alt="Note"></td>











      <td><strong>Note</strong>&nbsp;&nbsp;When
you finish using the
Elapsed Times VI to check your code, remove the VI before you build and
deploy your robot code because the Elapsed Times VI also uses a small
amount of memory and CPU time.</td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<br>











<br>











<h3><a name="generaltrouble">TroubleShooting General
Issues</a></h3>











<p class="Body">The
following table lists common issues you might
encounter when programming or working with the robot, as well as
solutions to these issues.</p>











<table class="Bordered">











  <tbody>











    <tr>











      <th class="Bordered">Issue</th>











      <th class="Bordered">Solution</th>











    </tr>











    <tr>











      <td class="Bordered">The
motors on the robot do not run when I
attempt to run them.</td>











      <td class="Bordered">First, make sure you are
running the FRC
Driver Station and have enabled Teleop mode. &nbsp;The FRC Driver
Station can be launched from the Start menu or from the Desktop
shortcut.<br>











      <br>











Use
the safety configuration VIs, available
for PWM, Relay, Solenoid, RobotDrive, and MotorControl, to ensure that
the loop that contains the set output does not run faster than the <strong>timeout
(ms)</strong> input value specified
in the safety configuration VI. If
the speed of the loop is not monitored and another loop starves the
loop that contains the set output, the robot may not respond to input
values, such as joystick values, and may not stop. The safety
configuration VIs are a safety feature to ensure the robot responds to
input values. <br>











      <br>











To find an example program that uses the safety configuration VIs,
click the <strong>Find FRC
Examples</strong> link in the <strong>Getting
Started</strong> window, and
double-click the <strong>FRC
Robotics»roboRIO&gt;&gt;Safety</strong>
folder. <br>











      <br>











Refer to the <a href="http://digital.ni.com/express.nsf/bycode/FRCTutorials">FRC
tutorials</a> on the National
Instruments <em>FIRST</em>
Community Web
site for information about using the safety configuration VIs. You also
can refer to the <em>LabVIEW Help</em>,
available by selecting <strong>Help»LabVIEW
Help</strong>. </td>











    </tr>











    <tr>











      <td class="Bordered">I
cannot access the Axis camera using the
FIRST Vision VIs.</td>











      <td class="Bordered">Ensure
the Axis camera is connected to the radio using an
Ethernet&nbsp;cable. <br>











      <br>











Refer to <a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#configcamera">Tutorial
3—Setting up the Axis
Camera</a> for more information
about configuring the camera. <br>











      <br>











Click the <strong>Find FRC
Examples</strong> link on the <strong>Getting
Started</strong> window to find
example programs that use the FIRST
Vision VIs. You also can access this information in the <em>LabVIEW
Help</em>, available by selecting <strong>Help»LabVIEW
Help</strong>.</td>











    </tr>











    <tr>











      <td class="Bordered">When
I try to run the roboRIO Imaging
Tool, the roboRIO Imaging Tool dialog box does not list any roboRIOs
connected to the host computer.</td>











      <td class="Bordered">Make sure you are connected to
the roboRIO
over USB. &nbsp;Use a USB cable to connect the computer to the USB
Device Port of the roboRIO (the single USB port next to the INPUT
power).<br>











      <br>











Check
the network firewall and ensure that
the firewall allows the computer to access the roboRIO. <br>











      <br>











You might need to disable the firewall for the roboRIO Imaging Tool
to run with no errors. </td>











    </tr>











    <tr>











      <td class="Bordered">When
I run the roboRIO Imaging Tool, the
tool stops while downloading an image to the roboRIO.</td>











      <td class="Bordered">Ensure
that the network firewall allows the
computer to access the roboRIO. <br>











      <br>











You might need to disable the firewall for the roboRIO Imaging Tool
to run with no errors. </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<h3>Using the WPI Robotics Library
VIs</h3>











<p class="Body">Use the WPI
Robotics Library VIs to interface with the roboRIO and perform tasks
such as reading and writing data to
sensors and driving motors.</p>











<p class="Body">Click the <strong>Find
FRC Examples</strong> link on
the <span style="font-weight: bold;">Support</span>
tab of the <strong>Getting Started</strong>
window to find example programs
that use the WPI Robotics Library VIs. You also can access this
information in the <em>LabVIEW
Help</em>, available by selecting <strong>Help»LabVIEW
Help</strong>.</p>











<h4>Reference Clusters</h4>











<p class="Body">Many of the
WPI Robotics Library VIs contain input and
output reference clusters, such as <strong>CompressorDevRef</strong>,
<strong>RelayDevRef</strong>,
and so on. Use these reference clusters to pass information about a
specific sensor or module between VIs.</p>











<p class="Body">For
example, the following figures illustrate how to
open (and start) a reference to an encoder, read the same
encoder,&nbsp;and then stop and close the corresponding reference.</p>











<p class="Body">
<img style="width: 322px; height: 72px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/FRC_beginVIrefex.gif"><br>











<strong>Figure 1</strong>:
Code to Use in the Begin VI
</p>











<br>











<p class="Body">
<img style="width: 348px; height: 67px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/FRC_teleopVIrefex.gif"><br>











<strong>Figure 2</strong>:
Code to Use in the Teleop VI
</p>











<br>











<p class="Body">
<img style="width: 359px; height: 67px;" alt="" src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/FRC_finishVIrefex.gif.gif"><br>











<strong>Figure 3</strong>:
Code to Use in the Finish VI
</p>











<p class="Body">In the
Begin VI, the WPI_EncoderOpen VI reserves an
available encoder index, starts the encoder, and returns an <strong>EncoderDevRef</strong>
output reference that identifies the encoder. Wire that reference to
the <strong></strong><strong>EncoderDevRef</strong>
input reference of the WPI_EncoderRefNum Registry Set VI to register
the refnum so that other template VIs can use the refnum. For example,
in the Teleop VI, you can use the WPI_EncoderRefnum Registry Get VI to
read and pass the EncoderDevRef to the WPI_EncoderGet VI to read the
current encoder value. Similarly, you can use the refnum in the Finish
VI to stop the encoder and release the resources it uses.</p>











<p class="Body">Wiring the <strong>EncoderDevRef</strong>
reference
cluster between VIs establishes a reference to the same encoder for
each VI. By using the reference cluster, you do not have to specify the
same information about the encoder for each VI.</p>











<table class="Borderless">











  <tbody>











    <tr>











      <td class="Icon"><img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/caution.gif" alt="Caution"></td>











      <td><span class="Dark-Red"><strong>Caution</strong>&nbsp;&nbsp;Do
not manually specify any information in a reference cluster. Always use
a corresponding Open VI for the sensor or module to create the
reference cluster that you then can wire to other VIs.</span></td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<p class="Body">All input
and output reference clusters contain at
least a <strong>DevStatus</strong>
cluster, which contains error
information and is similar to the LabVIEW error cluster.</p>











<p class="Body">Some
reference clusters also contain additional
controls or indicators unique to the sensor or module to which they
apply. For example, the <strong>EncoderDevRef</strong>
reference
cluster, shown below, contains a <strong>DevStatus</strong>
cluster as well as four encoder-specific controls: <strong>EncoderIndex</strong>,
<strong>CounterIndex</strong>,
<strong>DistancePerCount</strong>,
and <strong>Decoding
Type</strong>.</p>











<img src="./LabVIEW Robotics Programming Guide for FIRST Robotics Competition_files/EncoderDevRef.gif" alt="Input Reference Cluster">
<p class="Body"><strong>EncoderIndex</strong>
specifies the index of
the reserved encoder. Therefore, <strong>EncoderIndex</strong>
establishes a reference to a particular encoder.</p>











<h4>Error Handling</h4>











<p class="Body">When you
use reference clusters to connect VIs, you
also pass error information between those VIs. You can use this error
information to troubleshoot the application.</p>











<p class="Body">When using
reference clusters with the Encoder VIs, if
the Open VI runs normally, the <strong>DevStatus</strong>
cluster of
the <strong>EncoderDevRef</strong>
output reference cluster is empty.
The Open VI therefore does not pass any errors to the Start VI, and the
<strong>DevStatus</strong>
cluster of the <strong>EncoderDevRef</strong>
input reference cluster of the Start VI also is empty.</p>











<p class="Body">However,
suppose an error occurs when the Open VI
runs. The Open VI returns an error in the <strong>DevStatus</strong>
cluster of the <strong>EncoderDevRef</strong>
output reference cluster
and passes this information to the <strong>EncoderDevRef</strong>
input reference cluster of the Get VI. Because the Get VI receives an
error, it does not execute and passes the error information to the
Close VI, again through the <strong>EncoderDevRef</strong>
reference
cluster. If you wire an indicator to the <strong>error
out</strong>
output of the Close VI, <strong>error
out</strong> returns the
cumulative error information for all VIs preceding and including the
Close VI. From this error information, you can determine that an error
originated with the Open VI, and you can troubleshoot that error
accordingly.</p>











<p class="Body">Many of the
WPI Robotics Library VIs also contain <strong>error
in</strong> and <strong>error
out</strong> clusters. You can use
these
clusters to merge error information from different parts of an
application. Each WPI Robotics Library VI merges the error information
it receives from the input reference cluster and the <strong>error
in</strong>
cluster and returns this merged information in both the output
reference cluster and the <strong>error
out</strong> cluster.</p>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>











<hr>
<br>











<br>











<h2><a name="onlinetutorials">Online Forums and
Tutorials</a></h2>











<p class="Body">Refer to
the <a href="http://digital.ni.com/express.nsf/bycode/NIFRCcommunity" target="_blank">FIRST Robotics Competition Community</a>
on the
National Instruments Web site to read and share support information.</p>











<p class="Body">Refer to
the <a href="http://digital.ni.com/express.nsf/bycode/FRCTutorials" target="_blank">FRC Training Material and Resources</a>
on the
National Instruments Web site to access step-by-step instructions for
programming the robot.</p>











<h2>Other Help Resources</h2>











<h4>Programming in LabVIEW</h4>











<p class="Body">The
following document contains information that you
may find helpful as you use LabVIEW:</p>











<ul>











  <li><em>LabVIEW
Help</em>—Use the <em>LabVIEW
Help</em> to
access information about LabVIEW programming concepts, step-by-step
instructions for using LabVIEW, and reference information about LabVIEW
VIs, functions, palettes, menus, tools, properties, methods, events,
dialog boxes, and so on. Access the <em>LabVIEW
Help</em> by selecting <strong>Help»LabVIEW
Help</strong> in LabVIEW.</li>











</ul>











<h4>Using the roboRIO</h4>











<p class="Body">The
following documents contain information that you
may find helpful as you use the roboRIO:</p>











<ul>











  <li><em>NI roboRIO Specifications</em>—This
document provides specifications for the NI roboRIO. Access this manual
by
navigating Program Files to the <span class="Monospace">National
Instruments\roboRIO\manuals</span>
directory and opening&nbsp;<span class="Monospace">NI
roboRIO
Specifications.pdf<br>











    </span></li>











  <li><em>NI roboRIO User Manual</em>—This
document includes
general information about the NI roboRIO. Access this manual by
navigating Program Files to
the <span class="Monospace">National
Instruments\roboRIO\manuals</span>
directory and opening&nbsp;<span class="Monospace">NI
roboRIO User
Manual.pdf.</span></li>











</ul>











<p class="Body"><a href="file:///C:/Program%20Files%20(x86)/National%20Instruments/LabVIEW%202016/manuals/FRC_Programming_Guide/index.html#TOC">Table of
Contents</a></p>













</body></html>